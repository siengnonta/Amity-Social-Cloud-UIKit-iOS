#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
#ifndef AMITYSDK_SWIFT_H
#define AMITYSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import Realm;
@import Security;
#endif

#import <AmitySDK/AmitySDK.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AmitySDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSString;
@class NSNumber;
@protocol ASCAuthSessionProtocol;
@class ASCNetworkService;

SWIFT_CLASS("_TtC8AmitySDK14ASCAuthService")
@interface ASCAuthService : NSObject
@property (nonatomic, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nullable userInternalId;
@property (nonatomic, readonly, copy) NSString * _Nullable clientId;
@property (nonatomic) BOOL isAuthenticating;
@property (nonatomic, copy) void (^ _Nullable didUpdateAccessToken)(NSString * _Nonnull);
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey sessionService:(id <ASCAuthSessionProtocol> _Nonnull)sessionService networkService:(ASCNetworkService * _Nonnull)networkService OBJC_DESIGNATED_INITIALIZER;
- (void)registerDeviceWithUserId:(NSString * _Nonnull)userId displayName:(NSString * _Nullable)displayName authToken:(NSString * _Nullable)authToken completion:(void (^ _Nonnull)(NSDictionary<NSString *, id> * _Nullable, NSError * _Nullable))completion;
- (void)createNewSessionWithUserId:(NSString * _Nonnull)userId;
- (void)clearSession;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP8AmitySDK22ASCAuthSessionProtocol_")
@protocol ASCAuthSessionProtocol
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable internalUserId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (void)setupSessionWithApiKey:(NSString * _Nonnull)apiKey;
- (void)createNewSessionWithApiKey:(NSString * _Nonnull)apiKey;
- (void)clearSession;
- (void)saveTokenWithAccessToken:(NSString * _Nonnull)accessToken refreshToken:(NSString * _Nonnull)refreshToken;
- (void)saveUserIdWithId:(NSString * _Nonnull)id;
- (void)saveInternalUserId:(NSString * _Nullable)id;
- (BOOL)isAccessTokenValid SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_PROTOCOL("_TtP8AmitySDK27ASCConnectionStatusDelegate_")
@protocol ASCConnectionStatusDelegate
/// Delegate method which gets called everytime socket connection status changes
- (void)didChangeSocketConnectionStatusWithStatus:(AmityConnectionStatus)status;
/// Delegate method which gets called everytime mqtt connection status changes
- (void)didChangeMqttConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end

@class RLMRealm;

SWIFT_CLASS("_TtC8AmitySDK18ASCDatabaseService")
@interface ASCDatabaseService : NSObject
@property (nonatomic, strong) RLMRealm * _Nullable authRealm;
@property (nonatomic, strong) RLMRealm * _Nullable dataRealm;
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey OBJC_DESIGNATED_INITIALIZER;
- (void)setupAuthRealmWithObjectClasses:(NSArray<Class> * _Nonnull)objectClasses;
- (void)setupDataRealmWithObjectClasses:(NSArray<Class> * _Nonnull)objectClasses;
/// Note: This method should be called from within realm transaction
- (void)deleteAuthRealmData;
/// Note: This method should be called from within realm transaction
- (void)deleteDataRealmData;
- (void)deleteLocalData;
- (BOOL)isDatabaseReady SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK32ASCDevicePushNotificationService")
@interface ASCDevicePushNotificationService : NSObject
- (nonnull instancetype)initWithAuthService:(ASCAuthService * _Nonnull)authService networkService:(ASCNetworkService * _Nonnull)networkService OBJC_DESIGNATED_INITIALIZER;
- (void)registerDeviceForPushNotificationWithDeviceToken:(NSString * _Nonnull)deviceToken completion:(AmityRequestCompletion _Nullable)completion;
- (void)unregisterDeviceForPushNotificationWithUserId:(NSString * _Nullable)userId completion:(AmityRequestCompletion _Nullable)completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP8AmitySDK25ASCMQTTConnectionDelegate_")
@protocol ASCMQTTConnectionDelegate <NSObject>
/// Called when mqtt connection status changes. State from MQTT connection
/// are mapped to AmityConnectionStatus & notified through delegate
- (void)didChangeMqttConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end

@protocol ASCNetworkConfigurationProtocol;

SWIFT_CLASS("_TtC8AmitySDK24ASCMQTTConnectionService")
@interface ASCMQTTConnectionService : NSObject
@property (nonatomic, weak) id <ASCMQTTConnectionDelegate> _Nullable delegate;
/// Current status of MQTT Connection
@property (nonatomic, readonly) AmityConnectionStatus connectionStatus;
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
/// Establishes mqtt connection
- (void)connectWithClientId:(NSString * _Nonnull)clientId userId:(NSString * _Nonnull)userId accessToken:(NSString * _Nonnull)accessToken;
/// Disables auto reconnect mechanisms & terminate mqtt connection.
- (void)disconnect;
- (void)subscribeWithTopic:(NSString * _Nonnull)topic;
- (void)unsubscribeWithTopic:(NSString * _Nonnull)topic;
- (void)unsubscribeWithTopics:(NSArray<NSString *> * _Nonnull)topics;
- (void)publishWithTopic:(NSString * _Nonnull)topic message:(NSString * _Nonnull)message;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CocoaMQTT;
enum CocoaMQTTConnAck : uint8_t;
@class CocoaMQTTMessage;
enum CocoaMQTTConnState : uint8_t;

/// CocoaMQTT Delegate
SWIFT_PROTOCOL("_TtP8AmitySDK17CocoaMQTTDelegate_")
@protocol CocoaMQTTDelegate
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didConnectAck:(enum CocoaMQTTConnAck)ack;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishAck:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceiveMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didSubscribeTopics:(NSDictionary * _Nonnull)success failed:(NSArray<NSString *> * _Nonnull)failed;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didUnsubscribeTopics:(NSArray<NSString *> * _Nonnull)topics;
///
- (void)mqttDidPing:(CocoaMQTT * _Nonnull)mqtt;
///
- (void)mqttDidReceivePong:(CocoaMQTT * _Nonnull)mqtt;
///
- (void)mqttDidDisconnect:(CocoaMQTT * _Nonnull)mqtt withError:(NSError * _Nullable)err;
@optional
/// Manually validate SSL/TLS server certificate.
/// This method will be called if enable  <code>allowUntrustCACertificate</code>
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceive:(SecTrustRef _Nonnull)trust completionHandler:(void (^ _Nonnull)(BOOL))completionHandler;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishComplete:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didStateChangeTo:(enum CocoaMQTTConnState)state;
@end


@interface ASCMQTTConnectionService (SWIFT_EXTENSION(AmitySDK)) <CocoaMQTTDelegate>
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didConnectAck:(enum CocoaMQTTConnAck)ack;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceiveMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didSubscribeTopics:(NSDictionary * _Nonnull)success failed:(NSArray<NSString *> * _Nonnull)failed;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didUnsubscribeTopics:(NSArray<NSString *> * _Nonnull)topics;
- (void)mqttDidDisconnect:(CocoaMQTT * _Nonnull)mqtt withError:(NSError * _Nullable)err;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didStateChangeTo:(enum CocoaMQTTConnState)state;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishAck:(uint16_t)id;
- (void)mqttDidPing:(CocoaMQTT * _Nonnull)mqtt;
- (void)mqttDidReceivePong:(CocoaMQTT * _Nonnull)mqtt;
@end


SWIFT_PROTOCOL("_TtP8AmitySDK21ASCMQTTMessageHandler_")
@protocol ASCMQTTMessageHandler <NSObject>
- (void)handleResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response eventType:(NSString * _Nonnull)eventType;
@end


SWIFT_CLASS("_TtC8AmitySDK26ASCMQTTSubscriptionService")
@interface ASCMQTTSubscriptionService : NSObject
- (nonnull instancetype)initWithMqttService:(ASCMQTTConnectionService * _Nonnull)mqttService messageHandler:(id <ASCMQTTMessageHandler> _Nonnull)messageHandler OBJC_DESIGNATED_INITIALIZER;
- (void)configureWithUserId:(NSString * _Nonnull)userId;
- (void)subscribeWithTopic:(NSString * _Nonnull)topic completion:(AmityRequestCompletion _Nonnull)completion;
- (void)unsubscribeWithTopic:(NSString * _Nonnull)topic completion:(AmityRequestCompletion _Nonnull)completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum ASCNetworkType : NSInteger;
@class NSURL;

SWIFT_PROTOCOL("_TtP8AmitySDK31ASCNetworkConfigurationProtocol_")
@protocol ASCNetworkConfigurationProtocol
/// Constructs request endpoint using path for particular network type
/// \param type Network Type: rpc or http
///
/// \param path URL path. For example api/v3/something
///
///
/// returns:
/// Returns URL constructed using path. Else returns nil
- (NSURL * _Nullable)getRequestURLWithType:(enum ASCNetworkType)type path:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
/// Provides with base url for particular network type
/// \param networkType Network Type: rpc or http
///
///
/// returns:
/// Host url for particular network type
- (NSString * _Nonnull)getBaseURLWithNetworkType:(enum ASCNetworkType)networkType SWIFT_WARN_UNUSED_RESULT;
@end

enum AmityRegion : NSInteger;

/// Network configuration class for SDK.
SWIFT_CLASS("_TtC8AmitySDK23ASCNetworkConfiguration")
@interface ASCNetworkConfiguration : NSObject <ASCNetworkConfigurationProtocol>
/// Initializes network configuration for particular region
- (nonnull instancetype)initWithRegion:(enum AmityRegion)region OBJC_DESIGNATED_INITIALIZER;
/// Initializes network configuration with provided URL
/// If any url is empty or nil, default configuration is used.
- (nonnull instancetype)initWithHttpUrl:(NSString * _Nullable)httpUrl socketUrl:(NSString * _Nullable)socketUrl mqttUrl:(NSString * _Nullable)mqttUrl OBJC_DESIGNATED_INITIALIZER;
- (NSURL * _Nullable)getRequestURLWithType:(enum ASCNetworkType)type path:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getBaseURLWithNetworkType:(enum ASCNetworkType)networkType SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum which denotes different types of network this sdk connects to
typedef SWIFT_ENUM(NSInteger, ASCNetworkType, open) {
  ASCNetworkTypeRpc = 0,
  ASCNetworkTypeHttp = 1,
  ASCNetworkTypeMqtt = 2,
};



SWIFT_CLASS("_TtC8AmitySDK17ASCNetworkService")
@interface ASCNetworkService : NSObject
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK15ASCSessionModel")
@interface ASCSessionModel : RLMObject
+ (BOOL)shouldIncludeInDefaultSchema SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK17ASCSessionService")
@interface ASCSessionService : NSObject <ASCAuthSessionProtocol>
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable internalUserId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)initWithRealm:(RLMRealm * _Nonnull)realm OBJC_DESIGNATED_INITIALIZER;
/// Creates new session
- (void)createNewSessionWithApiKey:(NSString * _Nonnull)apiKey;
/// Saves token for existing session
- (void)saveTokenWithAccessToken:(NSString * _Nonnull)accessToken refreshToken:(NSString * _Nonnull)refreshToken;
/// Saves user id for existing session
- (void)saveUserIdWithId:(NSString * _Nonnull)id;
- (void)saveInternalUserId:(NSString * _Nullable)id;
/// If session exists for provided api key, it is used
/// else new session is created
- (void)setupSessionWithApiKey:(NSString * _Nonnull)apiKey;
/// Removes all session information from auth realm
- (void)clearSession;
/// Session is valid if accessToken is present & not empty
- (BOOL)isAccessTokenValid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Delegate for socket connection
SWIFT_PROTOCOL("_TtP8AmitySDK27ASCSocketConnectionDelegate_")
@protocol ASCSocketConnectionDelegate <NSObject>
/// This method is called for socket connection related error.
- (void)didReceiveSocketErrorWithError:(NSError * _Nonnull)error;
/// This method is called after socket manager instance is created
/// & is ready to be used.
- (void)didSetupSocketConnection;
/// This method is called everytime socket ios status changes.
- (void)didChangeSocketConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end


SWIFT_CLASS("_TtC8AmitySDK26ASCSocketConnectionService")
@interface ASCSocketConnectionService : NSObject
/// Delegate which notifies about connection status & error
@property (nonatomic, weak) id <ASCSocketConnectionDelegate> _Nullable delegate;
/// Status of default socket connection
@property (nonatomic, readonly) AmityConnectionStatus connectionStatus;
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
/// Establishes socket connection with server
- (void)connectWithAccessToken:(NSString * _Nonnull)accessToken;
/// Terminates socket connection with server.
- (void)disconnect;
/// Sends RPC request to server.
- (void)sendRPCRequestWithEndpoint:(NSString * _Nonnull)endpoint params:(NSArray * _Nonnull)params completion:(void (^ _Nullable)(NSArray * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Manages real time (rpc) events for Socket Connection.
SWIFT_CLASS("_TtC8AmitySDK21ASCSocketEventManager")
@interface ASCSocketEventManager : NSObject
- (nonnull instancetype)initWithConnection:(ASCSocketConnectionService * _Nonnull)connection OBJC_DESIGNATED_INITIALIZER;
/// Add listener for particular socket event. If socket connection
/// is not ready, then listener is added to the queue.
- (void)bindWithEvent:(NSString * _Nonnull)event completion:(void (^ _Nullable)(NSArray * _Nonnull))completion;
/// Unbinds listner for particular event
- (void)unbindWithEvent:(NSString * _Nonnull)event;
/// Tries to attach listner for all events in a queue.
/// If socket is not ready, then events would be added back to the queue.
- (void)bindEventsInQueue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK32AmityChannelNotificationSettings")
@interface AmityChannelNotificationSettings : NSObject
@property (nonatomic) BOOL isEnabled;
- (nonnull instancetype)initWithIsEnabled:(BOOL)isEnabled OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK21AmityChannelQueryType")
@interface AmityChannelQueryType : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull standard;)
+ (NSString * _Nonnull)standard SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy, getter=private) NSString * _Nonnull private_;)
+ (NSString * _Nonnull)private SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull broadcast;)
+ (NSString * _Nonnull)broadcast SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull conversation;)
+ (NSString * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull live;)
+ (NSString * _Nonnull)live SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull community;)
+ (NSString * _Nonnull)community SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Delegate for AmityClient instance. This delegate is used for
/// notifying various events or error from within the sdk.
SWIFT_PROTOCOL("_TtP8AmitySDK19AmityClientDelegate_")
@protocol AmityClientDelegate
/// Notifies about different asychronous error which can
/// occur within the sdk. These error can be
/// <ul>
///   <li>
///     when user is globally banned
///   </li>
///   <li>
///     when user has bad session or authentication etc.
///   </li>
/// </ul>
/// You can use the error message & error code and map it with
/// <code>AmityErrorCode</code> to know the type of the error.
/// \param error Error instance received from sdk
///
- (void)didReceiveErrorWithError:(NSError * _Nonnull)error;
/// Notifies when connection status changes in sdk.
/// \param status enum AmityConnectionStatus which defines different state of connection
///
- (void)didChangeConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end


/// Class for configuring endpoints for AmitySDK.
SWIFT_CLASS("_TtC8AmitySDK13AmityEndpoint")
@interface AmityEndpoint : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable httpUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable rpcUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable mqttUrl;
/// Initializes network endpoint with provided url parameters. If any url parameter is nil,
/// it uses default value of Global Region configuration.
/// \param httpUrl Valid http host url
///
/// \param rpcUrl Valid websocket host url
///
/// \param mqttUrl Valid mqtt host address without scheme i.e “broker.emqx.io”
///
- (nonnull instancetype)initWithHttpUrl:(NSString * _Nullable)httpUrl rpcUrl:(NSString * _Nullable)rpcUrl mqttHost:(NSString * _Nullable)mqttHost OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK20AmityFilePostBuilder")
@interface AmityFilePostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK21AmityImagePostBuilder")
@interface AmityImagePostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK26AmityLiveStreamPostBuilder")
@interface AmityLiveStreamPostBuilder : NSObject <AmityPostBuilder>
- (nonnull instancetype)initWithStreamId:(NSString * _Nonnull)streamId text:(NSString * _Nullable)text OBJC_DESIGNATED_INITIALIZER;
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum AmityLogLevel : NSInteger;

SWIFT_CLASS("_TtC8AmitySDK8AmityLog")
@interface AmityLog : NSObject
/// Set log level to print on console
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) enum AmityLogLevel logLevel;)
+ (enum AmityLogLevel)logLevel SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogLevel:(enum AmityLogLevel)value;
+ (void)debug:(id _Nonnull)info;
+ (void)warn:(id _Nonnull)info;
+ (void)error:(id _Nonnull)info;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AmityLogLevel, open) {
/// All debugging logs.
  AmityLogLevelDebug = 0,
/// Warning logs
  AmityLogLevelWarn = 1,
/// Error logs
  AmityLogLevelError = 2,
/// All types of logs
  AmityLogLevelAll = 3,
/// Don’t show any kinds of logs
  AmityLogLevelNone = 4,
};


/// AmityMentioneesBuilder which builds the mentionees payload.
SWIFT_CLASS("_TtC8AmitySDK22AmityMentioneesBuilder")
@interface AmityMentioneesBuilder : NSObject
/// Mention channel to be able to notify everyone
- (void)mentionChannel;
/// Mention users who must be notified
/// \param userIds the array of mentioned userIds
///
- (void)mentionUsersWithUserIds:(NSArray<NSString *> * _Nonnull)userIds;
/// Builds the dictionary for mentionees
- (NSArray<NSDictionary<NSString *, id> *> * _Nonnull)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class AmityUploadableFile;
@class NSURLRequest;

SWIFT_CLASS("_TtC8AmitySDK28AmityMultipartRequestBuilder")
@interface AmityMultipartRequestBuilder : NSObject
- (nonnull instancetype)initWithFiles:(NSArray<AmityUploadableFile *> * _Nonnull)files params:(NSDictionary<NSString *, id> * _Nullable)params endpoint:(NSString * _Nonnull)endpoint accessToken:(NSString * _Nonnull)accessToken OBJC_DESIGNATED_INITIALIZER;
- (NSURLRequest * _Nullable)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK24AmityPollCreationBuilder")
@interface AmityPollCreationBuilder : NSObject <AmityPollBuilder>
/// Returns the JSON representation of the data object needed for poll
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK20AmityPollPostBuilder")
@interface AmityPollPostBuilder : NSObject <AmityPostBuilder>
/// Returns the JSON representation of the data object needed for post
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// This class represents post query options.
SWIFT_CLASS("_TtC8AmitySDK21AmityPostQueryOptions")
@interface AmityPostQueryOptions : NSObject
/// The target type.
@property (nonatomic, readonly) AmityPostTargetType targetType;
/// The target id.
@property (nonatomic, readonly, copy) NSString * _Nonnull targetId;
/// The collection ordering.
@property (nonatomic, readonly) AmityPostQuerySortOption sortBy;
/// The <code>post.isDeleted</code> type to query.
@property (nonatomic, readonly) AmityQueryOption deletedOption;
/// Filter only specific <code>post.dataType</code>, specify <code>nil</code>to query all post types.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nullable filterPostTypes;
/// Create AmityPostQueryOptions instance.
/// \param targetType The target type.
///
/// \param targetId The target id.
///
/// \param sortBy The collection ordering.
///
/// \param deletedOption The <code>post.isDeleted</code> type to query.
///
/// \param filterPostTypes Filter only specific <code>post.dataType</code>, specify <code>nil</code>to query all post types.
///
- (nonnull instancetype)initWithTargetType:(AmityPostTargetType)targetType targetId:(NSString * _Nonnull)targetId sortBy:(AmityPostQuerySortOption)sortBy deletedOption:(AmityQueryOption)deletedOption filterPostTypes:(NSSet<NSString *> * _Nullable)filterPostTypes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, AmityRegion, open) {
/// Default region
  AmityRegionGlobal = 0,
/// Europe
  AmityRegionEU = 1,
/// Singapore
  AmityRegionSG = 2,
/// United States
  AmityRegionUS = 3,
};


SWIFT_CLASS("_TtC8AmitySDK21AmityRegionalEndpoint") SWIFT_DEPRECATED_MSG("This class will be removed in future. Please use `AmityClient(apiKey:_, region:_)` method with `AmityRegion` instead.")
@interface AmityRegionalEndpoint : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSData;

/// Class to represent the file that is being uploaded.
SWIFT_CLASS("_TtC8AmitySDK19AmityUploadableFile")
@interface AmityUploadableFile : NSObject
/// Identifier which uniquely identifies this file.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Data representing actual File.
@property (nonatomic, copy) NSData * _Nonnull fileData;
/// Name of the file being uploaded. Example: my-awesome-file.pdf.
/// Extension will be automatically extracted from your File Name
@property (nonatomic, copy) NSString * _Nullable fileName;
/// MimeType of the file being uploaded. Default value is “application/octet-stream”
@property (nonatomic, copy) NSString * _Nonnull mimeType;
/// Any metadata associated with the file. Right now its ignored
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull metaData;
/// Initializes the instance for this class.
- (nonnull instancetype)initWithFileData:(NSData * _Nonnull)fileData fileName:(NSString * _Nullable)fileName OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class AmityImageData;

SWIFT_CLASS("_TtC8AmitySDK22AmityUserUpdateBuilder")
@interface AmityUserUpdateBuilder : NSObject
/// Set display name for current user
/// \param name Display name to set. If you want to remove assigned display name, pass param nil or empty.
///
- (void)setDisplayName:(NSString * _Nullable)name;
/// Sets description for current user
/// \param description Description for the user.
///
- (void)setUserDescription:(NSString * _Nonnull)description;
/// Sets metadata for current user
/// \param metadata Dictionary containing metadata
///
- (void)setUserMetadata:(NSDictionary<NSString *, id> * _Nullable)metadata;
/// Sets custom url as an avatar url. This is useful if you want to assign the existing
/// avatar url as an avatar url.
/// You can only use this either this method or <code>setAvatar</code> for updating avatar. If both method
/// are used, then this method will be given priority and <code>setAvatar</code> input will be
/// discarded.
/// \param customURL Custom URL of the avatar to be assigned. If you want to remove
/// assigned url, set this parameter to nil.
///
- (void)setAvatarCustomUrl:(NSString * _Nullable)customURL;
/// Sets avatar for this user. Image for this avatar should be uploaded first using
/// <code>AmityFileRepository</code> and the <code>AmityImageData</code> returned upon completion should
/// be set as a parameter.
/// You can only use this either this method or <code>setAvatarCustomUrl</code> for updating avatar. If both method
/// are used, then <code>setAvatarCustomUrl</code> will be given priority and input from this method will be
/// discarded.
/// \param avatar <code>AmityImageData</code> returned upon successful upload of image using
/// <code>AmityFileRepository</code>. If you want to remove avatar, set this parameter to nil.
///
- (void)setAvatar:(AmityImageData * _Nullable)avatar;
- (NSDictionary<NSString *, id> * _Nonnull)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum AmityVideoDataQuality : NSInteger;

SWIFT_CLASS("_TtC8AmitySDK14AmityVideoData")
@interface AmityVideoData : NSObject
@property (nonatomic, copy) NSString * _Nonnull fileId;
@property (nonatomic, copy) NSString * _Nonnull fileURL;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull attributes;
- (nonnull instancetype)initWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
+ (NSString * _Nonnull)getStringValue:(enum AmityVideoDataQuality)quality SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM(NSInteger, AmityVideoDataQuality, open) {
  AmityVideoDataQualityOriginal = 0,
  AmityVideoDataQualityHigh = 1,
  AmityVideoDataQualityMedium = 2,
  AmityVideoDataQualityLow = 3,
};


SWIFT_CLASS("_TtC8AmitySDK21AmityVideoPostBuilder")
@interface AmityVideoPostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// MQTT Client
/// note:
/// GCDAsyncSocket need delegate to extend NSObject
SWIFT_CLASS("_TtC8AmitySDK9CocoaMQTT")
@interface CocoaMQTT : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Conn Ack
typedef SWIFT_ENUM(uint8_t, CocoaMQTTConnAck, open) {
  CocoaMQTTConnAckAccept = 0,
  CocoaMQTTConnAckUnacceptableProtocolVersion = 1,
  CocoaMQTTConnAckIdentifierRejected = 2,
  CocoaMQTTConnAckServerUnavailable = 3,
  CocoaMQTTConnAckBadUsernameOrPassword = 4,
  CocoaMQTTConnAckNotAuthorized = 5,
  CocoaMQTTConnAckReserved = 6,
};

/// Connection State
typedef SWIFT_ENUM(uint8_t, CocoaMQTTConnState, open) {
  CocoaMQTTConnStateDisconnected = 0,
  CocoaMQTTConnStateConnecting = 1,
  CocoaMQTTConnStateConnected = 2,
};



SWIFT_CLASS("_TtC8AmitySDK15CocoaMQTTLogger")
@interface CocoaMQTTLogger : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// MQTT Message
SWIFT_CLASS("_TtC8AmitySDK16CocoaMQTTMessage")
@interface CocoaMQTTMessage : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface CocoaMQTTMessage (SWIFT_EXTENSION(AmitySDK))
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// Quality of Service levels
typedef SWIFT_ENUM(uint8_t, CocoaMQTTQoS, open) {
/// At most once delivery
  CocoaMQTTQoSQos0 = 0,
/// At least once delivery
  CocoaMQTTQoSQos1 = 1,
/// Exactly once delivery
  CocoaMQTTQoSQos2 = 2,
/// !!! Used SUBACK frame only
  CocoaMQTTQoSFAILTURE = 0x80,
};


SWIFT_CLASS("_TtC8AmitySDK15CocoaMQTTSocket")
@interface CocoaMQTTSocket : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@class GCDAsyncSocket;

@interface CocoaMQTTSocket (SWIFT_EXTENSION(AmitySDK)) <GCDAsyncSocketDelegate>
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didConnectToHost:(NSString * _Nonnull)host port:(uint16_t)port;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didReceiveTrust:(SecTrustRef _Nonnull)trust completionHandler:(void (^ _Nonnull)(BOOL))completionHandler;
- (void)socketDidSecure:(GCDAsyncSocket * _Nonnull)sock;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didWriteDataWithTag:(NSInteger)tag;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didReadData:(NSData * _Nonnull)data withTag:(NSInteger)tag;
- (void)socketDidDisconnect:(GCDAsyncSocket * _Nonnull)sock withError:(NSError * _Nullable)err;
@end


SWIFT_CLASS("_TtCC8AmitySDK18CocoaMQTTWebSocket20FoundationConnection")
@interface FoundationConnection : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSURLSession;
@class NSURLSessionTask;
@class NSURLAuthenticationChallenge;
@class NSURLCredential;
@class NSURLSessionWebSocketTask;

SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.0) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15)
@interface FoundationConnection (SWIFT_EXTENSION(AmitySDK)) <NSURLSessionWebSocketDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
- (void)URLSession:(NSURLSession * _Nonnull)session webSocketTask:(NSURLSessionWebSocketTask * _Nonnull)webSocketTask didOpenWithProtocol:(NSString * _Nullable)protocol;
- (void)URLSession:(NSURLSession * _Nonnull)session webSocketTask:(NSURLSessionWebSocketTask * _Nonnull)webSocketTask didCloseWithCode:(NSURLSessionWebSocketCloseCode)closeCode reason:(NSData * _Nullable)reason;
@end

@class NSStream;

SWIFT_CLASS("_TtC8AmitySDK16FoundationStream")
@interface FoundationStream : NSObject <NSStreamDelegate>
/// Delegate for the stream methods. Processes incoming bytes
- (void)stream:(NSStream * _Nonnull)aStream handleEvent:(NSStreamEvent)eventCode;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end








/// A class that represents an emit that will request an ack that has not yet been sent.
/// Call <code>timingOut(after:callback:)</code> to complete the emit
/// Example:
/// \code
/// socket.emitWithAck("myEvent").timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK13OnAckCallback")
@interface OnAckCallback : NSObject
/// Completes an emitWithAck. If this isn’t called, the emit never happens.
/// \param seconds The number of seconds before this emit times out if an ack hasn’t been received.
///
/// \param callback The callback called when an ack is received, or when a timeout happens.
/// To check for timeout, use <code>SocketAckStatus</code>’s <code>noAck</code> case.
///
- (void)timingOutAfter:(double)seconds callback:(void (^ _Nonnull)(NSArray * _Nonnull))callback;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK19PostQueryStreamMeta")
@interface PostQueryStreamMeta : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable targetId;
@property (nonatomic, readonly, copy) NSString * _Nullable targetType;
@property (nonatomic, readonly) BOOL isGlobal;
@property (nonatomic, readonly) BOOL matchingParentPostOnly;
@property (nonatomic, readonly) AmityQueryOption deletedType;
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nullable dataTypes;
@property (nonatomic, readonly) AmityPostQuerySortOption sortedBy;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull etc;
- (nonnull instancetype)initWithTargetId:(NSString * _Nullable)targetId targetType:(NSString * _Nullable)targetType isGlobal:(BOOL)isGlobal matchingParentPostOnly:(BOOL)matchingParentPostOnly deletedType:(AmityQueryOption)deletedType dataTypes:(NSSet<NSString *> * _Nullable)dataTypes sortedBy:(AmityPostQuerySortOption)sortedBy etc:(NSArray<NSString *> * _Nonnull)etc OBJC_DESIGNATED_INITIALIZER;
- (NSString * _Nonnull)generateString SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A wrapper around Starscream’s SSLSecurity that provides a minimal Objective-C interface.
SWIFT_CLASS("_TtC8AmitySDK11SSLSecurity")
@interface SSLSecurity : NSObject
/// Creates a new SSLSecurity that specifies whether to use publicKeys or certificates should be used for SSL
/// pinning validation
/// \param usePublicKeys is to specific if the publicKeys or certificates should be used for SSL pinning
/// validation
///
- (nonnull instancetype)initWithUsePublicKeys:(BOOL)usePublicKeys;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SocketRawAckView;

/// A class that represents a waiting ack call.
/// <em>NOTE</em>: You should not store this beyond the life of the event handler.
SWIFT_CLASS("_TtC8AmitySDK16SocketAckEmitter")
@interface SocketAckEmitter : NSObject
/// A view into this emitter where emits do not check for binary data.
/// Usage:
/// \code
/// ack.rawEmitView.with(myObject)
///
/// \endcode<em>NOTE</em>: It is not safe to hold on to this view beyond the life of the socket.
@property (nonatomic, readonly, strong) SocketRawAckView * _Nonnull rawEmitView;
/// Call to ack receiving this event.
/// \param items An array of items to send when acking. Use <code>[]</code> to send nothing.
///
- (void)with:(NSArray * _Nonnull)items;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Represents some event that was received.
SWIFT_CLASS("_TtC8AmitySDK14SocketAnyEvent")
@interface SocketAnyEvent : NSObject
/// The event name.
@property (nonatomic, readonly, copy) NSString * _Nonnull event;
/// The data items for this event.
@property (nonatomic, readonly, copy) NSArray * _Nullable items;
/// The description of this event.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSHTTPCookie;
@class WebSocket;
@protocol SocketEngineClient;
enum SocketEnginePacketType : NSInteger;

/// The class that handles the engine.io protocol and transports.
/// See <code>SocketEnginePollable</code> and <code>SocketEngineWebsocket</code> for transport specific methods.
SWIFT_CLASS("_TtC8AmitySDK12SocketEngine")
@interface SocketEngine : NSObject <NSURLSessionDelegate>
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// If <code>true</code> the engine will attempt to use WebSocket compression.
@property (nonatomic, readonly) BOOL compress;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
/// <em>Do not touch this directly</em>
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket SWIFT_DEPRECATED_MSG("No longer needed, if we're not polling, then we must be doing websockets");
/// The WebSocket for this engine.
@property (nonatomic, readonly, strong) WebSocket * _Nullable ws;
/// The client for this engine.
@property (nonatomic, weak) id <SocketEngineClient> _Nullable client;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// WebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the WebSocket. This happens because when
/// the engine is attempting to upgrade to WebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param type The type of this message.
///
/// \param data Any data that this message has.
///
/// \param completion Callback called on transport write completion.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data completion:(void (^ _Nullable)(void))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Declares that a type will be a delegate to an engine.
SWIFT_PROTOCOL("_TtP8AmitySDK18SocketEngineClient_")
@protocol SocketEngineClient
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine receives a pong message.
- (void)engineDidReceivePong;
/// Called when the engine sends a ping to the server.
- (void)engineDidSendPing;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
/// Called when when upgrading the http connection to a websocket connection.
/// \param headers The http headers.
///
- (void)engineDidWebsocketUpgradeWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers;
@end

/// Represents the type of engine.io packet types.
typedef SWIFT_ENUM(NSInteger, SocketEnginePacketType, open) {
/// Open message.
  SocketEnginePacketTypeOpen = 0,
/// Close message.
  SocketEnginePacketTypeClose = 1,
/// Ping message.
  SocketEnginePacketTypePing = 2,
/// Pong message.
  SocketEnginePacketTypePong = 3,
/// Regular message.
  SocketEnginePacketTypeMessage = 4,
/// Upgrade message.
  SocketEnginePacketTypeUpgrade = 5,
/// NOOP.
  SocketEnginePacketTypeNoop = 6,
};


/// Specifies a SocketEngine.
SWIFT_PROTOCOL("_TtP8AmitySDK16SocketEngineSpec_")
@protocol SocketEngineSpec
/// The client for this engine.
@property (nonatomic, strong) id <SocketEngineClient> _Nullable client;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// If <code>true</code> the engine will attempt to use WebSocket compression.
@property (nonatomic, readonly) BOOL compress;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket SWIFT_DEPRECATED_MSG("No longer needed, if we're not polling, then we must be doing websockets");
/// The WebSocket for this engine.
@property (nonatomic, readonly, strong) WebSocket * _Nullable ws;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// WebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the WebSocket. This happens because when
/// the engine is attempting to upgrade to WebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param type The type of this message.
///
/// \param data Any data that this message has.
///
/// \param completion Callback called on transport write completion.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data completion:(void (^ _Nullable)(void))completion;
@end

@protocol SocketManagerSpec;
@class SocketRawView;
enum SocketIOStatus : NSInteger;
@class NSUUID;

/// Represents a socket.io-client.
/// Clients are created through a <code>SocketManager</code>, which owns the <code>SocketEngineSpec</code> that controls the connection to the server.
/// For example:
/// \code
/// // Create a socket for the /swift namespace
/// let socket = manager.socket(forNamespace: "/swift")
///
/// // Add some handlers and connect
///
/// \endcode<em>NOTE</em>: The client is not thread/queue safe, all interaction with the socket should be done on the <code>manager.handleQueue</code>
SWIFT_CLASS("_TtC8AmitySDK14SocketIOClient")
@interface SocketIOClient : NSObject
/// The namespace that this socket is currently connected to.
/// <em>Must</em> start with a <code>/</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull nsp;
/// The session id of this client.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The manager for this socket.
@property (nonatomic, readonly, weak) id <SocketManagerSpec> _Nullable manager;
/// A view into this socket where emits do not check for binary data.
/// Usage:
/// \code
/// socket.rawEmitView.emit("myEvent", myObject)
///
/// \endcode<em>NOTE</em>: It is not safe to hold on to this view beyond the life of the socket.
@property (nonatomic, readonly, strong) SocketRawView * _Nonnull rawEmitView;
/// The status of this client.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Type safe way to create a new SocketIOClient. <code>opts</code> can be omitted.
/// \param manager The manager for this socket.
///
/// \param nsp The namespace of the socket.
///
- (nonnull instancetype)initWithManager:(id <SocketManagerSpec> _Nonnull)manager nsp:(NSString * _Nonnull)nsp OBJC_DESIGNATED_INITIALIZER;
/// Connect to the server. The same as calling <code>connect(timeoutAfter:withHandler:)</code> with a timeout of 0.
/// Only call after adding your event listeners, unless you know what you’re doing.
- (void)connect;
/// Connect to the server. If we aren’t connected after <code>timeoutAfter</code> seconds, then <code>withHandler</code> is called.
/// Only call after adding your event listeners, unless you know what you’re doing.
/// \param timeoutAfter The number of seconds after which if we are not connected we assume the connection
/// has failed. Pass 0 to never timeout.
///
/// \param handler The handler to call when the client fails to connect.
///
- (void)connectWithTimeoutAfter:(double)timeoutAfter withHandler:(void (^ _Nullable)(void))handler;
/// Disconnects the socket.
/// This will cause the socket to leave the namespace it is associated to, as well as remove itself from the
/// <code>manager</code>.
- (void)disconnect;
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items;
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
/// \param completion Callback called on transport write completion.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items completion:(void (^ _Nullable)(void))completion;
/// Same as emitWithAck, but for Objective-C
/// <em>NOTE</em>: It is up to the server send an ack back, just calling this method does not mean the server will ack.
/// Check that your server’s api will ack the event being sent.
/// Example:
/// \code
/// socket.emitWithAck("myEvent", with: [1]).timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode\param event The event to send.
///
/// \param items The items to send with this event. Use <code>[]</code> to send nothing.
///
///
/// returns:
/// An <code>OnAckCallback</code>. You must call the <code>timingOut(after:)</code> method before the event will be sent.
- (OnAckCallback * _Nonnull)emitWithAck:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items SWIFT_WARN_UNUSED_RESULT;
/// Called when socket.io has acked one of our emits. Causes the corresponding ack callback to be called.
/// \param ack The number for this ack.
///
/// \param data The data sent back with this ack.
///
- (void)handleAck:(NSInteger)ack data:(NSArray * _Nonnull)data;
/// Called when we get an event from socket.io.
/// \param event The name of the event.
///
/// \param data The data that was sent with this event.
///
/// \param isInternalMessage Whether this event was sent internally. If <code>true</code> it is always sent to handlers.
///
/// \param ack If > 0 then this event expects to get an ack back from the client.
///
- (void)handleEvent:(NSString * _Nonnull)event data:(NSArray * _Nonnull)data isInternalMessage:(BOOL)isInternalMessage withAck:(NSInteger)ack;
/// Call when you wish to leave a namespace and disconnect this socket.
- (void)leaveNamespace;
/// Joins <code>nsp</code>.
- (void)joinNamespace;
/// Removes handler(s) based on an event name.
/// If you wish to remove a specific event, call the <code>off(id:)</code> with the UUID received from its <code>on</code> call.
/// \param event The event to remove handlers for.
///
- (void)off:(NSString * _Nonnull)event;
/// Removes a handler with the specified UUID gotten from an <code>on</code> or <code>once</code>
/// If you want to remove all events for an event, call the off <code>off(_:)</code> method with the event name.
/// \param id The UUID of the handler you wish to remove.
///
- (void)offWithId:(NSUUID * _Nonnull)id;
/// Adds a handler for an event.
/// \param event The event name for this handler.
///
/// \param callback The callback that will execute when this event is received.
///
///
/// returns:
/// A unique id for the handler that can be used to remove it.
- (NSUUID * _Nonnull)on:(NSString * _Nonnull)event callback:(void (^ _Nonnull)(NSArray * _Nonnull, SocketAckEmitter * _Nonnull))callback;
/// Adds a single-use handler for an event.
/// \param event The event name for this handler.
///
/// \param callback The callback that will execute when this event is received.
///
///
/// returns:
/// A unique id for the handler that can be used to remove it.
- (NSUUID * _Nonnull)once:(NSString * _Nonnull)event callback:(void (^ _Nonnull)(NSArray * _Nonnull, SocketAckEmitter * _Nonnull))callback;
/// Adds a handler that will be called on every event.
/// \param handler The callback that will execute whenever an event is received.
///
- (void)onAny:(void (^ _Nonnull)(SocketAnyEvent * _Nonnull))handler;
/// Tries to reconnect to the server.
- (void)reconnect SWIFT_UNAVAILABLE_MSG("Call the manager's reconnect method");
/// Removes all handlers.
/// Can be used after disconnecting to break any potential remaining retain cycles.
- (void)removeAllHandlers;
/// Puts the socket back into the connecting state.
/// Called when the manager detects a broken connection, or when a manual reconnect is triggered.
/// \param reason The reason this socket is reconnecting.
///
- (void)setReconnectingWithReason:(NSString * _Nonnull)reason;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Represents state of a manager or client.
typedef SWIFT_ENUM(NSInteger, SocketIOStatus, open) {
/// The client/manager has never been connected. Or the client has been reset.
  SocketIOStatusNotConnected = 0,
/// The client/manager was once connected, but not anymore.
  SocketIOStatusDisconnected = 1,
/// The client/manager is in the process of connecting.
  SocketIOStatusConnecting = 2,
/// The client/manager is currently connected.
  SocketIOStatusConnected = 3,
};


/// A manager for a socket.io connection.
/// A <code>SocketManagerSpec</code> is responsible for multiplexing multiple namespaces through a single <code>SocketEngineSpec</code>.
/// Example with <code>SocketManager</code>:
/// \code
/// let manager = SocketManager(socketURL: URL(string:"http://localhost:8080/")!)
/// let defaultNamespaceSocket = manager.defaultSocket
/// let swiftSocket = manager.socket(forNamespace: "/swift")
///
/// // defaultNamespaceSocket and swiftSocket both share a single connection to the server
///
/// \endcodeSockets created through the manager are retained by the manager. So at the very least, a single strong reference
/// to the manager must be maintained to keep sockets alive.
/// To disconnect a socket and remove it from the manager, either call <code>SocketIOClient.disconnect()</code> on the socket,
/// or call one of the <code>disconnectSocket</code> methods on this class.
SWIFT_PROTOCOL("_TtP8AmitySDK17SocketManagerSpec_")
@protocol SocketManagerSpec <SocketEngineClient>
/// Returns the socket associated with the default namespace (“/”).
@property (nonatomic, readonly, strong) SocketIOClient * _Nonnull defaultSocket;
/// The engine for this manager.
@property (nonatomic, strong) id <SocketEngineSpec> _Nullable engine;
/// If <code>true</code> then every time <code>connect</code> is called, a new engine will be created.
@property (nonatomic) BOOL forceNew;
/// The queue that all interaction with the client should occur on. This is the queue that event handlers are
/// called on.
@property (nonatomic, strong) dispatch_queue_t _Nonnull handleQueue;
/// The sockets in this manager indexed by namespace.
@property (nonatomic, copy) NSDictionary<NSString *, SocketIOClient *> * _Nonnull nsps;
/// If <code>true</code>, this manager will try and reconnect on any disconnects.
@property (nonatomic) BOOL reconnects;
/// The minimum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWait;
/// The maximum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWaitMax;
/// The randomization factor for calculating reconnect jitter.
@property (nonatomic) double randomizationFactor;
/// The URL of the socket.io server.
@property (nonatomic, readonly, copy) NSURL * _Nonnull socketURL;
/// The status of this manager.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Connects the underlying transport.
- (void)connect;
/// Connects a socket through this manager’s engine.
/// \param socket The socket who we should connect through this manager.
///
- (void)connectSocket:(SocketIOClient * _Nonnull)socket;
/// Called when the manager has disconnected from socket.io.
/// \param reason The reason for the disconnection.
///
- (void)didDisconnectWithReason:(NSString * _Nonnull)reason;
/// Disconnects the manager and all associated sockets.
- (void)disconnect;
/// Disconnects the given socket.
/// \param socket The socket to disconnect.
///
- (void)disconnectSocket:(SocketIOClient * _Nonnull)socket;
/// Disconnects the socket associated with <code>forNamespace</code>.
/// \param nsp The namespace to disconnect from.
///
- (void)disconnectSocketForNamespace:(NSString * _Nonnull)nsp;
/// Sends an event to the server on all namespaces in this manager.
/// \param event The event to send.
///
/// \param items The data to send with this event.
///
- (void)emitAll:(NSString * _Nonnull)event withItems:(NSArray * _Nonnull)items;
/// Tries to reconnect to the server.
/// This will cause a <code>disconnect</code> event to be emitted, as well as an <code>reconnectAttempt</code> event.
- (void)reconnect;
/// Removes the socket from the manager’s control.
/// After calling this method the socket should no longer be considered usable.
/// \param socket The socket to remove.
///
///
/// returns:
/// The socket removed, if it was owned by the manager.
- (SocketIOClient * _Nullable)removeSocket:(SocketIOClient * _Nonnull)socket;
/// Returns a <code>SocketIOClient</code> for the given namespace. This socket shares a transport with the manager.
/// Calling multiple times returns the same socket.
/// Sockets created from this method are retained by the manager.
/// Call one of the <code>disconnectSocket</code> methods on the implementing class to remove the socket from manager control.
/// Or call <code>SocketIOClient.disconnect()</code> on the client.
/// \param nsp The namespace for the socket.
///
///
/// returns:
/// A <code>SocketIOClient</code> for the given namespace.
- (SocketIOClient * _Nonnull)socketForNamespace:(NSString * _Nonnull)nsp SWIFT_WARN_UNUSED_RESULT;
@end


/// A manager for a socket.io connection.
/// A <code>SocketManager</code> is responsible for multiplexing multiple namespaces through a single <code>SocketEngineSpec</code>.
/// Example:
/// \code
/// let manager = SocketManager(socketURL: URL(string:"http://localhost:8080/")!)
/// let defaultNamespaceSocket = manager.defaultSocket
/// let swiftSocket = manager.socket(forNamespace: "/swift")
///
/// // defaultNamespaceSocket and swiftSocket both share a single connection to the server
///
/// \endcodeSockets created through the manager are retained by the manager. So at the very least, a single strong reference
/// to the manager must be maintained to keep sockets alive.
/// To disconnect a socket and remove it from the manager, either call <code>SocketIOClient.disconnect()</code> on the socket,
/// or call one of the <code>disconnectSocket</code> methods on this class.
/// <em>NOTE</em>: The manager is not thread/queue safe, all interaction with the manager should be done on the <code>handleQueue</code>
SWIFT_CLASS("_TtC8AmitySDK13SocketManager")
@interface SocketManager : NSObject <SocketManagerSpec>
/// The socket associated with the default namespace (“/”).
@property (nonatomic, readonly, strong) SocketIOClient * _Nonnull defaultSocket;
/// The URL of the socket.io server.
/// If changed after calling <code>init</code>, <code>forceNew</code> must be set to <code>true</code>, or it will only connect to the url set in the
/// init.
@property (nonatomic, readonly, copy) NSURL * _Nonnull socketURL;
/// The engine for this manager.
@property (nonatomic, strong) id <SocketEngineSpec> _Nullable engine;
/// If <code>true</code> then every time <code>connect</code> is called, a new engine will be created.
@property (nonatomic) BOOL forceNew;
/// The queue that all interaction with the client should occur on. This is the queue that event handlers are
/// called on.
/// <em>This should be a serial queue! Concurrent queues are not supported and might cause crashes and races</em>.
@property (nonatomic, strong) dispatch_queue_t _Nonnull handleQueue;
/// The sockets in this manager indexed by namespace.
@property (nonatomic, copy) NSDictionary<NSString *, SocketIOClient *> * _Nonnull nsps;
/// If <code>true</code>, this client will try and reconnect on any disconnects.
@property (nonatomic) BOOL reconnects;
/// The minimum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWait;
/// The maximum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWaitMax;
/// The randomization factor for calculating reconnect jitter.
@property (nonatomic) double randomizationFactor;
/// The status of this manager.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Not so type safe way to create a SocketIOClient, meant for Objective-C compatiblity.
/// If using Swift it’s recommended to use <code>init(socketURL: NSURL, options: Set<SocketIOClientOption>)</code>
/// \param socketURL The url of the socket.io server.
///
/// \param config The config for this socket.
///
- (nonnull instancetype)initWithSocketURL:(NSURL * _Nonnull)socketURL config:(NSDictionary<NSString *, id> * _Nullable)config;
/// Connects the underlying transport and the default namespace socket.
/// Override if you wish to attach a custom <code>SocketEngineSpec</code>.
- (void)connect;
/// Connects a socket through this manager’s engine.
/// \param socket The socket who we should connect through this manager.
///
- (void)connectSocket:(SocketIOClient * _Nonnull)socket;
/// Called when the manager has disconnected from socket.io.
/// \param reason The reason for the disconnection.
///
- (void)didDisconnectWithReason:(NSString * _Nonnull)reason;
/// Disconnects the manager and all associated sockets.
- (void)disconnect;
/// Disconnects the given socket.
/// This will remove the socket for the manager’s control, and make the socket instance useless and ready for
/// releasing.
/// \param socket The socket to disconnect.
///
- (void)disconnectSocket:(SocketIOClient * _Nonnull)socket;
/// Disconnects the socket associated with <code>forNamespace</code>.
/// This will remove the socket for the manager’s control, and make the socket instance useless and ready for
/// releasing.
/// \param nsp The namespace to disconnect from.
///
- (void)disconnectSocketForNamespace:(NSString * _Nonnull)nsp;
/// Sends an event to the server on all namespaces in this manager.
/// Same as <code>emitAll(_:_:)</code>, but meant for Objective-C.
/// \param event The event to send.
///
/// \param items The data to send with this event.
///
- (void)emitAll:(NSString * _Nonnull)event withItems:(NSArray * _Nonnull)items;
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine receives a pong message.
- (void)engineDidReceivePong;
/// Called when the sends a ping to the server.
- (void)engineDidSendPing;
/// Called when when upgrading the http connection to a websocket connection.
/// \param headers The http headers.
///
- (void)engineDidWebsocketUpgradeWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
/// Tries to reconnect to the server.
/// This will cause a <code>SocketClientEvent.reconnect</code> event to be emitted, as well as
/// <code>SocketClientEvent.reconnectAttempt</code> events.
- (void)reconnect;
/// Removes the socket from the manager’s control. One of the disconnect methods should be called before calling this
/// method.
/// After calling this method the socket should no longer be considered usable.
/// \param socket The socket to remove.
///
///
/// returns:
/// The socket removed, if it was owned by the manager.
- (SocketIOClient * _Nullable)removeSocket:(SocketIOClient * _Nonnull)socket;
/// Returns a <code>SocketIOClient</code> for the given namespace. This socket shares a transport with the manager.
/// Calling multiple times returns the same socket.
/// Sockets created from this method are retained by the manager.
/// Call one of the <code>disconnectSocket</code> methods on this class to remove the socket from manager control.
/// Or call <code>SocketIOClient.disconnect()</code> on the client.
/// \param nsp The namespace for the socket.
///
///
/// returns:
/// A <code>SocketIOClient</code> for the given namespace.
- (SocketIOClient * _Nonnull)socketForNamespace:(NSString * _Nonnull)nsp SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Class that gives a backwards compatible way to cause an emit not to recursively check for Data objects.
/// Usage:
/// \code
/// ack.rawEmitView.with(myObject)
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK16SocketRawAckView")
@interface SocketRawAckView : NSObject
/// Call to ack receiving this event.
/// \param items An array of items to send when acking. Use <code>[]</code> to send nothing.
///
- (void)with:(NSArray * _Nonnull)items;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class that gives a backwards compatible way to cause an emit not to recursively check for Data objects.
/// Usage:
/// \code
/// socket.rawEmitView.emit("myEvent", myObject)
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK13SocketRawView")
@interface SocketRawView : NSObject
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items;
/// Same as emitWithAck, but for Objective-C
/// <em>NOTE</em>: It is up to the server send an ack back, just calling this method does not mean the server will ack.
/// Check that your server’s api will ack the event being sent.
/// Example:
/// \code
/// socket.emitWithAck("myEvent", with: [1]).timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode\param event The event to send.
///
/// \param items The items to send with this event. Use <code>[]</code> to send nothing.
///
///
/// returns:
/// An <code>OnAckCallback</code>. You must call the <code>timingOut(after:)</code> method before the event will be sent.
- (OnAckCallback * _Nonnull)emitWithAck:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





SWIFT_CLASS("_TtC8AmitySDK9WebSocket")
@interface WebSocket : NSObject <NSStreamDelegate>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
#ifndef AMITYSDK_SWIFT_H
#define AMITYSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import Realm;
@import Security;
#endif

#import <AmitySDK/AmitySDK.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AmitySDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

@class NSString;
@class NSNumber;
@protocol ASCAuthSessionProtocol;
@class ASCNetworkService;

SWIFT_CLASS("_TtC8AmitySDK14ASCAuthService")
@interface ASCAuthService : NSObject
@property (nonatomic, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nullable userInternalId;
@property (nonatomic, readonly, copy) NSString * _Nullable clientId;
@property (nonatomic) BOOL isAuthenticating;
@property (nonatomic, copy) void (^ _Nullable didUpdateAccessToken)(NSString * _Nonnull);
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey sessionService:(id <ASCAuthSessionProtocol> _Nonnull)sessionService networkService:(ASCNetworkService * _Nonnull)networkService OBJC_DESIGNATED_INITIALIZER;
- (void)registerDeviceWithUserId:(NSString * _Nonnull)userId displayName:(NSString * _Nullable)displayName authToken:(NSString * _Nullable)authToken completion:(void (^ _Nonnull)(NSDictionary<NSString *, id> * _Nullable, NSError * _Nullable))completion;
- (void)createNewSessionWithUserId:(NSString * _Nonnull)userId;
- (void)clearSession;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP8AmitySDK22ASCAuthSessionProtocol_")
@protocol ASCAuthSessionProtocol
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable internalUserId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (void)setupSessionWithApiKey:(NSString * _Nonnull)apiKey;
- (void)createNewSessionWithApiKey:(NSString * _Nonnull)apiKey;
- (void)clearSession;
- (void)saveTokenWithAccessToken:(NSString * _Nonnull)accessToken refreshToken:(NSString * _Nonnull)refreshToken;
- (void)saveUserIdWithId:(NSString * _Nonnull)id;
- (void)saveInternalUserId:(NSString * _Nullable)id;
- (BOOL)isAccessTokenValid SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_PROTOCOL("_TtP8AmitySDK27ASCConnectionStatusDelegate_")
@protocol ASCConnectionStatusDelegate
/// Delegate method which gets called everytime socket connection status changes
- (void)didChangeSocketConnectionStatusWithStatus:(AmityConnectionStatus)status;
/// Delegate method which gets called everytime mqtt connection status changes
- (void)didChangeMqttConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end

@class RLMRealm;

SWIFT_CLASS("_TtC8AmitySDK18ASCDatabaseService")
@interface ASCDatabaseService : NSObject
@property (nonatomic, strong) RLMRealm * _Nullable authRealm;
@property (nonatomic, strong) RLMRealm * _Nullable dataRealm;
- (nonnull instancetype)initWithApiKey:(NSString * _Nonnull)apiKey OBJC_DESIGNATED_INITIALIZER;
- (void)setupAuthRealmWithObjectClasses:(NSArray<Class> * _Nonnull)objectClasses;
- (void)setupDataRealmWithObjectClasses:(NSArray<Class> * _Nonnull)objectClasses;
/// Note: This method should be called from within realm transaction
- (void)deleteAuthRealmData;
/// Note: This method should be called from within realm transaction
- (void)deleteDataRealmData;
- (void)deleteLocalData;
- (BOOL)isDatabaseReady SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK32ASCDevicePushNotificationService")
@interface ASCDevicePushNotificationService : NSObject
- (nonnull instancetype)initWithAuthService:(ASCAuthService * _Nonnull)authService networkService:(ASCNetworkService * _Nonnull)networkService OBJC_DESIGNATED_INITIALIZER;
- (void)registerDeviceForPushNotificationWithDeviceToken:(NSString * _Nonnull)deviceToken completion:(AmityRequestCompletion _Nullable)completion;
- (void)unregisterDeviceForPushNotificationWithUserId:(NSString * _Nullable)userId completion:(AmityRequestCompletion _Nullable)completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP8AmitySDK25ASCMQTTConnectionDelegate_")
@protocol ASCMQTTConnectionDelegate <NSObject>
/// Called when mqtt connection status changes. State from MQTT connection
/// are mapped to AmityConnectionStatus & notified through delegate
- (void)didChangeMqttConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end

@protocol ASCNetworkConfigurationProtocol;

SWIFT_CLASS("_TtC8AmitySDK24ASCMQTTConnectionService")
@interface ASCMQTTConnectionService : NSObject
@property (nonatomic, weak) id <ASCMQTTConnectionDelegate> _Nullable delegate;
/// Current status of MQTT Connection
@property (nonatomic, readonly) AmityConnectionStatus connectionStatus;
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
/// Establishes mqtt connection
- (void)connectWithClientId:(NSString * _Nonnull)clientId userId:(NSString * _Nonnull)userId accessToken:(NSString * _Nonnull)accessToken;
/// Disables auto reconnect mechanisms & terminate mqtt connection.
- (void)disconnect;
- (void)subscribeWithTopic:(NSString * _Nonnull)topic;
- (void)unsubscribeWithTopic:(NSString * _Nonnull)topic;
- (void)unsubscribeWithTopics:(NSArray<NSString *> * _Nonnull)topics;
- (void)publishWithTopic:(NSString * _Nonnull)topic message:(NSString * _Nonnull)message;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class CocoaMQTT;
enum CocoaMQTTConnAck : uint8_t;
@class CocoaMQTTMessage;
enum CocoaMQTTConnState : uint8_t;

/// CocoaMQTT Delegate
SWIFT_PROTOCOL("_TtP8AmitySDK17CocoaMQTTDelegate_")
@protocol CocoaMQTTDelegate
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didConnectAck:(enum CocoaMQTTConnAck)ack;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishAck:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceiveMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didSubscribeTopics:(NSDictionary * _Nonnull)success failed:(NSArray<NSString *> * _Nonnull)failed;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didUnsubscribeTopics:(NSArray<NSString *> * _Nonnull)topics;
///
- (void)mqttDidPing:(CocoaMQTT * _Nonnull)mqtt;
///
- (void)mqttDidReceivePong:(CocoaMQTT * _Nonnull)mqtt;
///
- (void)mqttDidDisconnect:(CocoaMQTT * _Nonnull)mqtt withError:(NSError * _Nullable)err;
@optional
/// Manually validate SSL/TLS server certificate.
/// This method will be called if enable  <code>allowUntrustCACertificate</code>
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceive:(SecTrustRef _Nonnull)trust completionHandler:(void (^ _Nonnull)(BOOL))completionHandler;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishComplete:(uint16_t)id;
///
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didStateChangeTo:(enum CocoaMQTTConnState)state;
@end


@interface ASCMQTTConnectionService (SWIFT_EXTENSION(AmitySDK)) <CocoaMQTTDelegate>
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didConnectAck:(enum CocoaMQTTConnAck)ack;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didReceiveMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didSubscribeTopics:(NSDictionary * _Nonnull)success failed:(NSArray<NSString *> * _Nonnull)failed;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didUnsubscribeTopics:(NSArray<NSString *> * _Nonnull)topics;
- (void)mqttDidDisconnect:(CocoaMQTT * _Nonnull)mqtt withError:(NSError * _Nullable)err;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didStateChangeTo:(enum CocoaMQTTConnState)state;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishMessage:(CocoaMQTTMessage * _Nonnull)message id:(uint16_t)id;
- (void)mqtt:(CocoaMQTT * _Nonnull)mqtt didPublishAck:(uint16_t)id;
- (void)mqttDidPing:(CocoaMQTT * _Nonnull)mqtt;
- (void)mqttDidReceivePong:(CocoaMQTT * _Nonnull)mqtt;
@end


SWIFT_PROTOCOL("_TtP8AmitySDK21ASCMQTTMessageHandler_")
@protocol ASCMQTTMessageHandler <NSObject>
- (void)handleResponseWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response eventType:(NSString * _Nonnull)eventType;
@end


SWIFT_CLASS("_TtC8AmitySDK26ASCMQTTSubscriptionService")
@interface ASCMQTTSubscriptionService : NSObject
- (nonnull instancetype)initWithMqttService:(ASCMQTTConnectionService * _Nonnull)mqttService messageHandler:(id <ASCMQTTMessageHandler> _Nonnull)messageHandler OBJC_DESIGNATED_INITIALIZER;
- (void)configureWithUserId:(NSString * _Nonnull)userId;
- (void)subscribeWithTopic:(NSString * _Nonnull)topic completion:(AmityRequestCompletion _Nonnull)completion;
- (void)unsubscribeWithTopic:(NSString * _Nonnull)topic completion:(AmityRequestCompletion _Nonnull)completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum ASCNetworkType : NSInteger;
@class NSURL;

SWIFT_PROTOCOL("_TtP8AmitySDK31ASCNetworkConfigurationProtocol_")
@protocol ASCNetworkConfigurationProtocol
/// Constructs request endpoint using path for particular network type
/// \param type Network Type: rpc or http
///
/// \param path URL path. For example api/v3/something
///
///
/// returns:
/// Returns URL constructed using path. Else returns nil
- (NSURL * _Nullable)getRequestURLWithType:(enum ASCNetworkType)type path:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
/// Provides with base url for particular network type
/// \param networkType Network Type: rpc or http
///
///
/// returns:
/// Host url for particular network type
- (NSString * _Nonnull)getBaseURLWithNetworkType:(enum ASCNetworkType)networkType SWIFT_WARN_UNUSED_RESULT;
@end

enum AmityRegion : NSInteger;

/// Network configuration class for SDK.
SWIFT_CLASS("_TtC8AmitySDK23ASCNetworkConfiguration")
@interface ASCNetworkConfiguration : NSObject <ASCNetworkConfigurationProtocol>
/// Initializes network configuration for particular region
- (nonnull instancetype)initWithRegion:(enum AmityRegion)region OBJC_DESIGNATED_INITIALIZER;
/// Initializes network configuration with provided URL
/// If any url is empty or nil, default configuration is used.
- (nonnull instancetype)initWithHttpUrl:(NSString * _Nullable)httpUrl socketUrl:(NSString * _Nullable)socketUrl mqttUrl:(NSString * _Nullable)mqttUrl OBJC_DESIGNATED_INITIALIZER;
- (NSURL * _Nullable)getRequestURLWithType:(enum ASCNetworkType)type path:(NSString * _Nonnull)path SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)getBaseURLWithNetworkType:(enum ASCNetworkType)networkType SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Enum which denotes different types of network this sdk connects to
typedef SWIFT_ENUM(NSInteger, ASCNetworkType, open) {
  ASCNetworkTypeRpc = 0,
  ASCNetworkTypeHttp = 1,
  ASCNetworkTypeMqtt = 2,
};



SWIFT_CLASS("_TtC8AmitySDK17ASCNetworkService")
@interface ASCNetworkService : NSObject
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK15ASCSessionModel")
@interface ASCSessionModel : RLMObject
+ (BOOL)shouldIncludeInDefaultSchema SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK17ASCSessionService")
@interface ASCSessionService : NSObject <ASCAuthSessionProtocol>
@property (nonatomic, readonly, copy) NSString * _Nullable userId;
@property (nonatomic, readonly, copy) NSString * _Nullable internalUserId;
@property (nonatomic, readonly, copy) NSString * _Nullable accessToken;
@property (nonatomic, readonly, copy) NSString * _Nonnull apiKey;
@property (nonatomic, readonly, copy) NSString * _Nullable sessionId;
- (nonnull instancetype)initWithRealm:(RLMRealm * _Nonnull)realm OBJC_DESIGNATED_INITIALIZER;
/// Creates new session
- (void)createNewSessionWithApiKey:(NSString * _Nonnull)apiKey;
/// Saves token for existing session
- (void)saveTokenWithAccessToken:(NSString * _Nonnull)accessToken refreshToken:(NSString * _Nonnull)refreshToken;
/// Saves user id for existing session
- (void)saveUserIdWithId:(NSString * _Nonnull)id;
- (void)saveInternalUserId:(NSString * _Nullable)id;
/// If session exists for provided api key, it is used
/// else new session is created
- (void)setupSessionWithApiKey:(NSString * _Nonnull)apiKey;
/// Removes all session information from auth realm
- (void)clearSession;
/// Session is valid if accessToken is present & not empty
- (BOOL)isAccessTokenValid SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Delegate for socket connection
SWIFT_PROTOCOL("_TtP8AmitySDK27ASCSocketConnectionDelegate_")
@protocol ASCSocketConnectionDelegate <NSObject>
/// This method is called for socket connection related error.
- (void)didReceiveSocketErrorWithError:(NSError * _Nonnull)error;
/// This method is called after socket manager instance is created
/// & is ready to be used.
- (void)didSetupSocketConnection;
/// This method is called everytime socket ios status changes.
- (void)didChangeSocketConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end


SWIFT_CLASS("_TtC8AmitySDK26ASCSocketConnectionService")
@interface ASCSocketConnectionService : NSObject
/// Delegate which notifies about connection status & error
@property (nonatomic, weak) id <ASCSocketConnectionDelegate> _Nullable delegate;
/// Status of default socket connection
@property (nonatomic, readonly) AmityConnectionStatus connectionStatus;
- (nonnull instancetype)initWithConfig:(id <ASCNetworkConfigurationProtocol> _Nonnull)config OBJC_DESIGNATED_INITIALIZER;
/// Establishes socket connection with server
- (void)connectWithAccessToken:(NSString * _Nonnull)accessToken;
/// Terminates socket connection with server.
- (void)disconnect;
/// Sends RPC request to server.
- (void)sendRPCRequestWithEndpoint:(NSString * _Nonnull)endpoint params:(NSArray * _Nonnull)params completion:(void (^ _Nullable)(NSArray * _Nullable, NSError * _Nullable))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Manages real time (rpc) events for Socket Connection.
SWIFT_CLASS("_TtC8AmitySDK21ASCSocketEventManager")
@interface ASCSocketEventManager : NSObject
- (nonnull instancetype)initWithConnection:(ASCSocketConnectionService * _Nonnull)connection OBJC_DESIGNATED_INITIALIZER;
/// Add listener for particular socket event. If socket connection
/// is not ready, then listener is added to the queue.
- (void)bindWithEvent:(NSString * _Nonnull)event completion:(void (^ _Nullable)(NSArray * _Nonnull))completion;
/// Unbinds listner for particular event
- (void)unbindWithEvent:(NSString * _Nonnull)event;
/// Tries to attach listner for all events in a queue.
/// If socket is not ready, then events would be added back to the queue.
- (void)bindEventsInQueue;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK32AmityChannelNotificationSettings")
@interface AmityChannelNotificationSettings : NSObject
@property (nonatomic) BOOL isEnabled;
- (nonnull instancetype)initWithIsEnabled:(BOOL)isEnabled OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK21AmityChannelQueryType")
@interface AmityChannelQueryType : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull standard;)
+ (NSString * _Nonnull)standard SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy, getter=private) NSString * _Nonnull private_;)
+ (NSString * _Nonnull)private SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull broadcast;)
+ (NSString * _Nonnull)broadcast SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull conversation;)
+ (NSString * _Nonnull)conversation SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull live;)
+ (NSString * _Nonnull)live SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull community;)
+ (NSString * _Nonnull)community SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Delegate for AmityClient instance. This delegate is used for
/// notifying various events or error from within the sdk.
SWIFT_PROTOCOL("_TtP8AmitySDK19AmityClientDelegate_")
@protocol AmityClientDelegate
/// Notifies about different asychronous error which can
/// occur within the sdk. These error can be
/// <ul>
///   <li>
///     when user is globally banned
///   </li>
///   <li>
///     when user has bad session or authentication etc.
///   </li>
/// </ul>
/// You can use the error message & error code and map it with
/// <code>AmityErrorCode</code> to know the type of the error.
/// \param error Error instance received from sdk
///
- (void)didReceiveErrorWithError:(NSError * _Nonnull)error;
/// Notifies when connection status changes in sdk.
/// \param status enum AmityConnectionStatus which defines different state of connection
///
- (void)didChangeConnectionStatusWithStatus:(AmityConnectionStatus)status;
@end


/// Class for configuring endpoints for AmitySDK.
SWIFT_CLASS("_TtC8AmitySDK13AmityEndpoint")
@interface AmityEndpoint : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable httpUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable rpcUrl;
@property (nonatomic, readonly, copy) NSString * _Nullable mqttUrl;
/// Initializes network endpoint with provided url parameters. If any url parameter is nil,
/// it uses default value of Global Region configuration.
/// \param httpUrl Valid http host url
///
/// \param rpcUrl Valid websocket host url
///
/// \param mqttUrl Valid mqtt host address without scheme i.e “broker.emqx.io”
///
- (nonnull instancetype)initWithHttpUrl:(NSString * _Nullable)httpUrl rpcUrl:(NSString * _Nullable)rpcUrl mqttHost:(NSString * _Nullable)mqttHost OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK20AmityFilePostBuilder")
@interface AmityFilePostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK21AmityImagePostBuilder")
@interface AmityImagePostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK26AmityLiveStreamPostBuilder")
@interface AmityLiveStreamPostBuilder : NSObject <AmityPostBuilder>
- (nonnull instancetype)initWithStreamId:(NSString * _Nonnull)streamId text:(NSString * _Nullable)text OBJC_DESIGNATED_INITIALIZER;
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum AmityLogLevel : NSInteger;

SWIFT_CLASS("_TtC8AmitySDK8AmityLog")
@interface AmityLog : NSObject
/// Set log level to print on console
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) enum AmityLogLevel logLevel;)
+ (enum AmityLogLevel)logLevel SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogLevel:(enum AmityLogLevel)value;
+ (void)debug:(id _Nonnull)info;
+ (void)warn:(id _Nonnull)info;
+ (void)error:(id _Nonnull)info;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, AmityLogLevel, open) {
/// All debugging logs.
  AmityLogLevelDebug = 0,
/// Warning logs
  AmityLogLevelWarn = 1,
/// Error logs
  AmityLogLevelError = 2,
/// All types of logs
  AmityLogLevelAll = 3,
/// Don’t show any kinds of logs
  AmityLogLevelNone = 4,
};


/// AmityMentioneesBuilder which builds the mentionees payload.
SWIFT_CLASS("_TtC8AmitySDK22AmityMentioneesBuilder")
@interface AmityMentioneesBuilder : NSObject
/// Mention channel to be able to notify everyone
- (void)mentionChannel;
/// Mention users who must be notified
/// \param userIds the array of mentioned userIds
///
- (void)mentionUsersWithUserIds:(NSArray<NSString *> * _Nonnull)userIds;
/// Builds the dictionary for mentionees
- (NSArray<NSDictionary<NSString *, id> *> * _Nonnull)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class AmityUploadableFile;
@class NSURLRequest;

SWIFT_CLASS("_TtC8AmitySDK28AmityMultipartRequestBuilder")
@interface AmityMultipartRequestBuilder : NSObject
- (nonnull instancetype)initWithFiles:(NSArray<AmityUploadableFile *> * _Nonnull)files params:(NSDictionary<NSString *, id> * _Nullable)params endpoint:(NSString * _Nonnull)endpoint accessToken:(NSString * _Nonnull)accessToken OBJC_DESIGNATED_INITIALIZER;
- (NSURLRequest * _Nullable)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK24AmityPollCreationBuilder")
@interface AmityPollCreationBuilder : NSObject <AmityPollBuilder>
/// Returns the JSON representation of the data object needed for poll
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC8AmitySDK20AmityPollPostBuilder")
@interface AmityPollPostBuilder : NSObject <AmityPostBuilder>
/// Returns the JSON representation of the data object needed for post
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// This class represents post query options.
SWIFT_CLASS("_TtC8AmitySDK21AmityPostQueryOptions")
@interface AmityPostQueryOptions : NSObject
/// The target type.
@property (nonatomic, readonly) AmityPostTargetType targetType;
/// The target id.
@property (nonatomic, readonly, copy) NSString * _Nonnull targetId;
/// The collection ordering.
@property (nonatomic, readonly) AmityPostQuerySortOption sortBy;
/// The <code>post.isDeleted</code> type to query.
@property (nonatomic, readonly) AmityQueryOption deletedOption;
/// Filter only specific <code>post.dataType</code>, specify <code>nil</code>to query all post types.
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nullable filterPostTypes;
/// Create AmityPostQueryOptions instance.
/// \param targetType The target type.
///
/// \param targetId The target id.
///
/// \param sortBy The collection ordering.
///
/// \param deletedOption The <code>post.isDeleted</code> type to query.
///
/// \param filterPostTypes Filter only specific <code>post.dataType</code>, specify <code>nil</code>to query all post types.
///
- (nonnull instancetype)initWithTargetType:(AmityPostTargetType)targetType targetId:(NSString * _Nonnull)targetId sortBy:(AmityPostQuerySortOption)sortBy deletedOption:(AmityQueryOption)deletedOption filterPostTypes:(NSSet<NSString *> * _Nullable)filterPostTypes OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, AmityRegion, open) {
/// Default region
  AmityRegionGlobal = 0,
/// Europe
  AmityRegionEU = 1,
/// Singapore
  AmityRegionSG = 2,
/// United States
  AmityRegionUS = 3,
};


SWIFT_CLASS("_TtC8AmitySDK21AmityRegionalEndpoint") SWIFT_DEPRECATED_MSG("This class will be removed in future. Please use `AmityClient(apiKey:_, region:_)` method with `AmityRegion` instead.")
@interface AmityRegionalEndpoint : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSData;

/// Class to represent the file that is being uploaded.
SWIFT_CLASS("_TtC8AmitySDK19AmityUploadableFile")
@interface AmityUploadableFile : NSObject
/// Identifier which uniquely identifies this file.
@property (nonatomic, copy) NSString * _Nonnull identifier;
/// Data representing actual File.
@property (nonatomic, copy) NSData * _Nonnull fileData;
/// Name of the file being uploaded. Example: my-awesome-file.pdf.
/// Extension will be automatically extracted from your File Name
@property (nonatomic, copy) NSString * _Nullable fileName;
/// MimeType of the file being uploaded. Default value is “application/octet-stream”
@property (nonatomic, copy) NSString * _Nonnull mimeType;
/// Any metadata associated with the file. Right now its ignored
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull metaData;
/// Initializes the instance for this class.
- (nonnull instancetype)initWithFileData:(NSData * _Nonnull)fileData fileName:(NSString * _Nullable)fileName OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class AmityImageData;

SWIFT_CLASS("_TtC8AmitySDK22AmityUserUpdateBuilder")
@interface AmityUserUpdateBuilder : NSObject
/// Set display name for current user
/// \param name Display name to set. If you want to remove assigned display name, pass param nil or empty.
///
- (void)setDisplayName:(NSString * _Nullable)name;
/// Sets description for current user
/// \param description Description for the user.
///
- (void)setUserDescription:(NSString * _Nonnull)description;
/// Sets metadata for current user
/// \param metadata Dictionary containing metadata
///
- (void)setUserMetadata:(NSDictionary<NSString *, id> * _Nullable)metadata;
/// Sets custom url as an avatar url. This is useful if you want to assign the existing
/// avatar url as an avatar url.
/// You can only use this either this method or <code>setAvatar</code> for updating avatar. If both method
/// are used, then this method will be given priority and <code>setAvatar</code> input will be
/// discarded.
/// \param customURL Custom URL of the avatar to be assigned. If you want to remove
/// assigned url, set this parameter to nil.
///
- (void)setAvatarCustomUrl:(NSString * _Nullable)customURL;
/// Sets avatar for this user. Image for this avatar should be uploaded first using
/// <code>AmityFileRepository</code> and the <code>AmityImageData</code> returned upon completion should
/// be set as a parameter.
/// You can only use this either this method or <code>setAvatarCustomUrl</code> for updating avatar. If both method
/// are used, then <code>setAvatarCustomUrl</code> will be given priority and input from this method will be
/// discarded.
/// \param avatar <code>AmityImageData</code> returned upon successful upload of image using
/// <code>AmityFileRepository</code>. If you want to remove avatar, set this parameter to nil.
///
- (void)setAvatar:(AmityImageData * _Nullable)avatar;
- (NSDictionary<NSString *, id> * _Nonnull)build SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

enum AmityVideoDataQuality : NSInteger;

SWIFT_CLASS("_TtC8AmitySDK14AmityVideoData")
@interface AmityVideoData : NSObject
@property (nonatomic, copy) NSString * _Nonnull fileId;
@property (nonatomic, copy) NSString * _Nonnull fileURL;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull attributes;
- (nonnull instancetype)initWithResponse:(NSDictionary<NSString *, id> * _Nonnull)response OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
+ (NSString * _Nonnull)getStringValue:(enum AmityVideoDataQuality)quality SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM(NSInteger, AmityVideoDataQuality, open) {
  AmityVideoDataQualityOriginal = 0,
  AmityVideoDataQualityHigh = 1,
  AmityVideoDataQualityMedium = 2,
  AmityVideoDataQualityLow = 3,
};


SWIFT_CLASS("_TtC8AmitySDK21AmityVideoPostBuilder")
@interface AmityVideoPostBuilder : NSObject <AmityPostBuilder>
- (NSDictionary<NSString *, id> * _Null_unspecified)build SWIFT_WARN_UNUSED_RESULT;
- (NSDictionary<NSString *, id> * _Null_unspecified)buildForPostUpdate SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// MQTT Client
/// note:
/// GCDAsyncSocket need delegate to extend NSObject
SWIFT_CLASS("_TtC8AmitySDK9CocoaMQTT")
@interface CocoaMQTT : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





/// Conn Ack
typedef SWIFT_ENUM(uint8_t, CocoaMQTTConnAck, open) {
  CocoaMQTTConnAckAccept = 0,
  CocoaMQTTConnAckUnacceptableProtocolVersion = 1,
  CocoaMQTTConnAckIdentifierRejected = 2,
  CocoaMQTTConnAckServerUnavailable = 3,
  CocoaMQTTConnAckBadUsernameOrPassword = 4,
  CocoaMQTTConnAckNotAuthorized = 5,
  CocoaMQTTConnAckReserved = 6,
};

/// Connection State
typedef SWIFT_ENUM(uint8_t, CocoaMQTTConnState, open) {
  CocoaMQTTConnStateDisconnected = 0,
  CocoaMQTTConnStateConnecting = 1,
  CocoaMQTTConnStateConnected = 2,
};



SWIFT_CLASS("_TtC8AmitySDK15CocoaMQTTLogger")
@interface CocoaMQTTLogger : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// MQTT Message
SWIFT_CLASS("_TtC8AmitySDK16CocoaMQTTMessage")
@interface CocoaMQTTMessage : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface CocoaMQTTMessage (SWIFT_EXTENSION(AmitySDK))
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@end

/// Quality of Service levels
typedef SWIFT_ENUM(uint8_t, CocoaMQTTQoS, open) {
/// At most once delivery
  CocoaMQTTQoSQos0 = 0,
/// At least once delivery
  CocoaMQTTQoSQos1 = 1,
/// Exactly once delivery
  CocoaMQTTQoSQos2 = 2,
/// !!! Used SUBACK frame only
  CocoaMQTTQoSFAILTURE = 0x80,
};


SWIFT_CLASS("_TtC8AmitySDK15CocoaMQTTSocket")
@interface CocoaMQTTSocket : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@class GCDAsyncSocket;

@interface CocoaMQTTSocket (SWIFT_EXTENSION(AmitySDK)) <GCDAsyncSocketDelegate>
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didConnectToHost:(NSString * _Nonnull)host port:(uint16_t)port;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didReceiveTrust:(SecTrustRef _Nonnull)trust completionHandler:(void (^ _Nonnull)(BOOL))completionHandler;
- (void)socketDidSecure:(GCDAsyncSocket * _Nonnull)sock;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didWriteDataWithTag:(NSInteger)tag;
- (void)socket:(GCDAsyncSocket * _Nonnull)sock didReadData:(NSData * _Nonnull)data withTag:(NSInteger)tag;
- (void)socketDidDisconnect:(GCDAsyncSocket * _Nonnull)sock withError:(NSError * _Nullable)err;
@end


SWIFT_CLASS("_TtCC8AmitySDK18CocoaMQTTWebSocket20FoundationConnection")
@interface FoundationConnection : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSURLSession;
@class NSURLSessionTask;
@class NSURLAuthenticationChallenge;
@class NSURLCredential;
@class NSURLSessionWebSocketTask;

SWIFT_AVAILABILITY(tvos,introduced=13.0) SWIFT_AVAILABILITY(watchos,introduced=6.0) SWIFT_AVAILABILITY(ios,introduced=13.0) SWIFT_AVAILABILITY(macos,introduced=10.15)
@interface FoundationConnection (SWIFT_EXTENSION(AmitySDK)) <NSURLSessionWebSocketDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
- (void)URLSession:(NSURLSession * _Nonnull)session webSocketTask:(NSURLSessionWebSocketTask * _Nonnull)webSocketTask didOpenWithProtocol:(NSString * _Nullable)protocol;
- (void)URLSession:(NSURLSession * _Nonnull)session webSocketTask:(NSURLSessionWebSocketTask * _Nonnull)webSocketTask didCloseWithCode:(NSURLSessionWebSocketCloseCode)closeCode reason:(NSData * _Nullable)reason;
@end

@class NSStream;

SWIFT_CLASS("_TtC8AmitySDK16FoundationStream")
@interface FoundationStream : NSObject <NSStreamDelegate>
/// Delegate for the stream methods. Processes incoming bytes
- (void)stream:(NSStream * _Nonnull)aStream handleEvent:(NSStreamEvent)eventCode;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end








/// A class that represents an emit that will request an ack that has not yet been sent.
/// Call <code>timingOut(after:callback:)</code> to complete the emit
/// Example:
/// \code
/// socket.emitWithAck("myEvent").timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK13OnAckCallback")
@interface OnAckCallback : NSObject
/// Completes an emitWithAck. If this isn’t called, the emit never happens.
/// \param seconds The number of seconds before this emit times out if an ack hasn’t been received.
///
/// \param callback The callback called when an ack is received, or when a timeout happens.
/// To check for timeout, use <code>SocketAckStatus</code>’s <code>noAck</code> case.
///
- (void)timingOutAfter:(double)seconds callback:(void (^ _Nonnull)(NSArray * _Nonnull))callback;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC8AmitySDK19PostQueryStreamMeta")
@interface PostQueryStreamMeta : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable targetId;
@property (nonatomic, readonly, copy) NSString * _Nullable targetType;
@property (nonatomic, readonly) BOOL isGlobal;
@property (nonatomic, readonly) BOOL matchingParentPostOnly;
@property (nonatomic, readonly) AmityQueryOption deletedType;
@property (nonatomic, readonly, copy) NSSet<NSString *> * _Nullable dataTypes;
@property (nonatomic, readonly) AmityPostQuerySortOption sortedBy;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull etc;
- (nonnull instancetype)initWithTargetId:(NSString * _Nullable)targetId targetType:(NSString * _Nullable)targetType isGlobal:(BOOL)isGlobal matchingParentPostOnly:(BOOL)matchingParentPostOnly deletedType:(AmityQueryOption)deletedType dataTypes:(NSSet<NSString *> * _Nullable)dataTypes sortedBy:(AmityPostQuerySortOption)sortedBy etc:(NSArray<NSString *> * _Nonnull)etc OBJC_DESIGNATED_INITIALIZER;
- (NSString * _Nonnull)generateString SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A wrapper around Starscream’s SSLSecurity that provides a minimal Objective-C interface.
SWIFT_CLASS("_TtC8AmitySDK11SSLSecurity")
@interface SSLSecurity : NSObject
/// Creates a new SSLSecurity that specifies whether to use publicKeys or certificates should be used for SSL
/// pinning validation
/// \param usePublicKeys is to specific if the publicKeys or certificates should be used for SSL pinning
/// validation
///
- (nonnull instancetype)initWithUsePublicKeys:(BOOL)usePublicKeys;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class SocketRawAckView;

/// A class that represents a waiting ack call.
/// <em>NOTE</em>: You should not store this beyond the life of the event handler.
SWIFT_CLASS("_TtC8AmitySDK16SocketAckEmitter")
@interface SocketAckEmitter : NSObject
/// A view into this emitter where emits do not check for binary data.
/// Usage:
/// \code
/// ack.rawEmitView.with(myObject)
///
/// \endcode<em>NOTE</em>: It is not safe to hold on to this view beyond the life of the socket.
@property (nonatomic, readonly, strong) SocketRawAckView * _Nonnull rawEmitView;
/// Call to ack receiving this event.
/// \param items An array of items to send when acking. Use <code>[]</code> to send nothing.
///
- (void)with:(NSArray * _Nonnull)items;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Represents some event that was received.
SWIFT_CLASS("_TtC8AmitySDK14SocketAnyEvent")
@interface SocketAnyEvent : NSObject
/// The event name.
@property (nonatomic, readonly, copy) NSString * _Nonnull event;
/// The data items for this event.
@property (nonatomic, readonly, copy) NSArray * _Nullable items;
/// The description of this event.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSHTTPCookie;
@class WebSocket;
@protocol SocketEngineClient;
enum SocketEnginePacketType : NSInteger;

/// The class that handles the engine.io protocol and transports.
/// See <code>SocketEnginePollable</code> and <code>SocketEngineWebsocket</code> for transport specific methods.
SWIFT_CLASS("_TtC8AmitySDK12SocketEngine")
@interface SocketEngine : NSObject <NSURLSessionDelegate>
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// If <code>true</code> the engine will attempt to use WebSocket compression.
@property (nonatomic, readonly) BOOL compress;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
/// <em>Do not touch this directly</em>
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket SWIFT_DEPRECATED_MSG("No longer needed, if we're not polling, then we must be doing websockets");
/// The WebSocket for this engine.
@property (nonatomic, readonly, strong) WebSocket * _Nullable ws;
/// The client for this engine.
@property (nonatomic, weak) id <SocketEngineClient> _Nullable client;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// WebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the WebSocket. This happens because when
/// the engine is attempting to upgrade to WebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param type The type of this message.
///
/// \param data Any data that this message has.
///
/// \param completion Callback called on transport write completion.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data completion:(void (^ _Nullable)(void))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Declares that a type will be a delegate to an engine.
SWIFT_PROTOCOL("_TtP8AmitySDK18SocketEngineClient_")
@protocol SocketEngineClient
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine receives a pong message.
- (void)engineDidReceivePong;
/// Called when the engine sends a ping to the server.
- (void)engineDidSendPing;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
/// Called when when upgrading the http connection to a websocket connection.
/// \param headers The http headers.
///
- (void)engineDidWebsocketUpgradeWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers;
@end

/// Represents the type of engine.io packet types.
typedef SWIFT_ENUM(NSInteger, SocketEnginePacketType, open) {
/// Open message.
  SocketEnginePacketTypeOpen = 0,
/// Close message.
  SocketEnginePacketTypeClose = 1,
/// Ping message.
  SocketEnginePacketTypePing = 2,
/// Pong message.
  SocketEnginePacketTypePong = 3,
/// Regular message.
  SocketEnginePacketTypeMessage = 4,
/// Upgrade message.
  SocketEnginePacketTypeUpgrade = 5,
/// NOOP.
  SocketEnginePacketTypeNoop = 6,
};


/// Specifies a SocketEngine.
SWIFT_PROTOCOL("_TtP8AmitySDK16SocketEngineSpec_")
@protocol SocketEngineSpec
/// The client for this engine.
@property (nonatomic, strong) id <SocketEngineClient> _Nullable client;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// If <code>true</code> the engine will attempt to use WebSocket compression.
@property (nonatomic, readonly) BOOL compress;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket SWIFT_DEPRECATED_MSG("No longer needed, if we're not polling, then we must be doing websockets");
/// The WebSocket for this engine.
@property (nonatomic, readonly, strong) WebSocket * _Nullable ws;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary<NSString *, id> * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// WebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the WebSocket. This happens because when
/// the engine is attempting to upgrade to WebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param type The type of this message.
///
/// \param data Any data that this message has.
///
/// \param completion Callback called on transport write completion.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data completion:(void (^ _Nullable)(void))completion;
@end

@protocol SocketManagerSpec;
@class SocketRawView;
enum SocketIOStatus : NSInteger;
@class NSUUID;

/// Represents a socket.io-client.
/// Clients are created through a <code>SocketManager</code>, which owns the <code>SocketEngineSpec</code> that controls the connection to the server.
/// For example:
/// \code
/// // Create a socket for the /swift namespace
/// let socket = manager.socket(forNamespace: "/swift")
///
/// // Add some handlers and connect
///
/// \endcode<em>NOTE</em>: The client is not thread/queue safe, all interaction with the socket should be done on the <code>manager.handleQueue</code>
SWIFT_CLASS("_TtC8AmitySDK14SocketIOClient")
@interface SocketIOClient : NSObject
/// The namespace that this socket is currently connected to.
/// <em>Must</em> start with a <code>/</code>.
@property (nonatomic, readonly, copy) NSString * _Nonnull nsp;
/// The session id of this client.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The manager for this socket.
@property (nonatomic, readonly, weak) id <SocketManagerSpec> _Nullable manager;
/// A view into this socket where emits do not check for binary data.
/// Usage:
/// \code
/// socket.rawEmitView.emit("myEvent", myObject)
///
/// \endcode<em>NOTE</em>: It is not safe to hold on to this view beyond the life of the socket.
@property (nonatomic, readonly, strong) SocketRawView * _Nonnull rawEmitView;
/// The status of this client.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Type safe way to create a new SocketIOClient. <code>opts</code> can be omitted.
/// \param manager The manager for this socket.
///
/// \param nsp The namespace of the socket.
///
- (nonnull instancetype)initWithManager:(id <SocketManagerSpec> _Nonnull)manager nsp:(NSString * _Nonnull)nsp OBJC_DESIGNATED_INITIALIZER;
/// Connect to the server. The same as calling <code>connect(timeoutAfter:withHandler:)</code> with a timeout of 0.
/// Only call after adding your event listeners, unless you know what you’re doing.
- (void)connect;
/// Connect to the server. If we aren’t connected after <code>timeoutAfter</code> seconds, then <code>withHandler</code> is called.
/// Only call after adding your event listeners, unless you know what you’re doing.
/// \param timeoutAfter The number of seconds after which if we are not connected we assume the connection
/// has failed. Pass 0 to never timeout.
///
/// \param handler The handler to call when the client fails to connect.
///
- (void)connectWithTimeoutAfter:(double)timeoutAfter withHandler:(void (^ _Nullable)(void))handler;
/// Disconnects the socket.
/// This will cause the socket to leave the namespace it is associated to, as well as remove itself from the
/// <code>manager</code>.
- (void)disconnect;
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items;
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
/// \param completion Callback called on transport write completion.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items completion:(void (^ _Nullable)(void))completion;
/// Same as emitWithAck, but for Objective-C
/// <em>NOTE</em>: It is up to the server send an ack back, just calling this method does not mean the server will ack.
/// Check that your server’s api will ack the event being sent.
/// Example:
/// \code
/// socket.emitWithAck("myEvent", with: [1]).timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode\param event The event to send.
///
/// \param items The items to send with this event. Use <code>[]</code> to send nothing.
///
///
/// returns:
/// An <code>OnAckCallback</code>. You must call the <code>timingOut(after:)</code> method before the event will be sent.
- (OnAckCallback * _Nonnull)emitWithAck:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items SWIFT_WARN_UNUSED_RESULT;
/// Called when socket.io has acked one of our emits. Causes the corresponding ack callback to be called.
/// \param ack The number for this ack.
///
/// \param data The data sent back with this ack.
///
- (void)handleAck:(NSInteger)ack data:(NSArray * _Nonnull)data;
/// Called when we get an event from socket.io.
/// \param event The name of the event.
///
/// \param data The data that was sent with this event.
///
/// \param isInternalMessage Whether this event was sent internally. If <code>true</code> it is always sent to handlers.
///
/// \param ack If > 0 then this event expects to get an ack back from the client.
///
- (void)handleEvent:(NSString * _Nonnull)event data:(NSArray * _Nonnull)data isInternalMessage:(BOOL)isInternalMessage withAck:(NSInteger)ack;
/// Call when you wish to leave a namespace and disconnect this socket.
- (void)leaveNamespace;
/// Joins <code>nsp</code>.
- (void)joinNamespace;
/// Removes handler(s) based on an event name.
/// If you wish to remove a specific event, call the <code>off(id:)</code> with the UUID received from its <code>on</code> call.
/// \param event The event to remove handlers for.
///
- (void)off:(NSString * _Nonnull)event;
/// Removes a handler with the specified UUID gotten from an <code>on</code> or <code>once</code>
/// If you want to remove all events for an event, call the off <code>off(_:)</code> method with the event name.
/// \param id The UUID of the handler you wish to remove.
///
- (void)offWithId:(NSUUID * _Nonnull)id;
/// Adds a handler for an event.
/// \param event The event name for this handler.
///
/// \param callback The callback that will execute when this event is received.
///
///
/// returns:
/// A unique id for the handler that can be used to remove it.
- (NSUUID * _Nonnull)on:(NSString * _Nonnull)event callback:(void (^ _Nonnull)(NSArray * _Nonnull, SocketAckEmitter * _Nonnull))callback;
/// Adds a single-use handler for an event.
/// \param event The event name for this handler.
///
/// \param callback The callback that will execute when this event is received.
///
///
/// returns:
/// A unique id for the handler that can be used to remove it.
- (NSUUID * _Nonnull)once:(NSString * _Nonnull)event callback:(void (^ _Nonnull)(NSArray * _Nonnull, SocketAckEmitter * _Nonnull))callback;
/// Adds a handler that will be called on every event.
/// \param handler The callback that will execute whenever an event is received.
///
- (void)onAny:(void (^ _Nonnull)(SocketAnyEvent * _Nonnull))handler;
/// Tries to reconnect to the server.
- (void)reconnect SWIFT_UNAVAILABLE_MSG("Call the manager's reconnect method");
/// Removes all handlers.
/// Can be used after disconnecting to break any potential remaining retain cycles.
- (void)removeAllHandlers;
/// Puts the socket back into the connecting state.
/// Called when the manager detects a broken connection, or when a manual reconnect is triggered.
/// \param reason The reason this socket is reconnecting.
///
- (void)setReconnectingWithReason:(NSString * _Nonnull)reason;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Represents state of a manager or client.
typedef SWIFT_ENUM(NSInteger, SocketIOStatus, open) {
/// The client/manager has never been connected. Or the client has been reset.
  SocketIOStatusNotConnected = 0,
/// The client/manager was once connected, but not anymore.
  SocketIOStatusDisconnected = 1,
/// The client/manager is in the process of connecting.
  SocketIOStatusConnecting = 2,
/// The client/manager is currently connected.
  SocketIOStatusConnected = 3,
};


/// A manager for a socket.io connection.
/// A <code>SocketManagerSpec</code> is responsible for multiplexing multiple namespaces through a single <code>SocketEngineSpec</code>.
/// Example with <code>SocketManager</code>:
/// \code
/// let manager = SocketManager(socketURL: URL(string:"http://localhost:8080/")!)
/// let defaultNamespaceSocket = manager.defaultSocket
/// let swiftSocket = manager.socket(forNamespace: "/swift")
///
/// // defaultNamespaceSocket and swiftSocket both share a single connection to the server
///
/// \endcodeSockets created through the manager are retained by the manager. So at the very least, a single strong reference
/// to the manager must be maintained to keep sockets alive.
/// To disconnect a socket and remove it from the manager, either call <code>SocketIOClient.disconnect()</code> on the socket,
/// or call one of the <code>disconnectSocket</code> methods on this class.
SWIFT_PROTOCOL("_TtP8AmitySDK17SocketManagerSpec_")
@protocol SocketManagerSpec <SocketEngineClient>
/// Returns the socket associated with the default namespace (“/”).
@property (nonatomic, readonly, strong) SocketIOClient * _Nonnull defaultSocket;
/// The engine for this manager.
@property (nonatomic, strong) id <SocketEngineSpec> _Nullable engine;
/// If <code>true</code> then every time <code>connect</code> is called, a new engine will be created.
@property (nonatomic) BOOL forceNew;
/// The queue that all interaction with the client should occur on. This is the queue that event handlers are
/// called on.
@property (nonatomic, strong) dispatch_queue_t _Nonnull handleQueue;
/// The sockets in this manager indexed by namespace.
@property (nonatomic, copy) NSDictionary<NSString *, SocketIOClient *> * _Nonnull nsps;
/// If <code>true</code>, this manager will try and reconnect on any disconnects.
@property (nonatomic) BOOL reconnects;
/// The minimum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWait;
/// The maximum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWaitMax;
/// The randomization factor for calculating reconnect jitter.
@property (nonatomic) double randomizationFactor;
/// The URL of the socket.io server.
@property (nonatomic, readonly, copy) NSURL * _Nonnull socketURL;
/// The status of this manager.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Connects the underlying transport.
- (void)connect;
/// Connects a socket through this manager’s engine.
/// \param socket The socket who we should connect through this manager.
///
- (void)connectSocket:(SocketIOClient * _Nonnull)socket;
/// Called when the manager has disconnected from socket.io.
/// \param reason The reason for the disconnection.
///
- (void)didDisconnectWithReason:(NSString * _Nonnull)reason;
/// Disconnects the manager and all associated sockets.
- (void)disconnect;
/// Disconnects the given socket.
/// \param socket The socket to disconnect.
///
- (void)disconnectSocket:(SocketIOClient * _Nonnull)socket;
/// Disconnects the socket associated with <code>forNamespace</code>.
/// \param nsp The namespace to disconnect from.
///
- (void)disconnectSocketForNamespace:(NSString * _Nonnull)nsp;
/// Sends an event to the server on all namespaces in this manager.
/// \param event The event to send.
///
/// \param items The data to send with this event.
///
- (void)emitAll:(NSString * _Nonnull)event withItems:(NSArray * _Nonnull)items;
/// Tries to reconnect to the server.
/// This will cause a <code>disconnect</code> event to be emitted, as well as an <code>reconnectAttempt</code> event.
- (void)reconnect;
/// Removes the socket from the manager’s control.
/// After calling this method the socket should no longer be considered usable.
/// \param socket The socket to remove.
///
///
/// returns:
/// The socket removed, if it was owned by the manager.
- (SocketIOClient * _Nullable)removeSocket:(SocketIOClient * _Nonnull)socket;
/// Returns a <code>SocketIOClient</code> for the given namespace. This socket shares a transport with the manager.
/// Calling multiple times returns the same socket.
/// Sockets created from this method are retained by the manager.
/// Call one of the <code>disconnectSocket</code> methods on the implementing class to remove the socket from manager control.
/// Or call <code>SocketIOClient.disconnect()</code> on the client.
/// \param nsp The namespace for the socket.
///
///
/// returns:
/// A <code>SocketIOClient</code> for the given namespace.
- (SocketIOClient * _Nonnull)socketForNamespace:(NSString * _Nonnull)nsp SWIFT_WARN_UNUSED_RESULT;
@end


/// A manager for a socket.io connection.
/// A <code>SocketManager</code> is responsible for multiplexing multiple namespaces through a single <code>SocketEngineSpec</code>.
/// Example:
/// \code
/// let manager = SocketManager(socketURL: URL(string:"http://localhost:8080/")!)
/// let defaultNamespaceSocket = manager.defaultSocket
/// let swiftSocket = manager.socket(forNamespace: "/swift")
///
/// // defaultNamespaceSocket and swiftSocket both share a single connection to the server
///
/// \endcodeSockets created through the manager are retained by the manager. So at the very least, a single strong reference
/// to the manager must be maintained to keep sockets alive.
/// To disconnect a socket and remove it from the manager, either call <code>SocketIOClient.disconnect()</code> on the socket,
/// or call one of the <code>disconnectSocket</code> methods on this class.
/// <em>NOTE</em>: The manager is not thread/queue safe, all interaction with the manager should be done on the <code>handleQueue</code>
SWIFT_CLASS("_TtC8AmitySDK13SocketManager")
@interface SocketManager : NSObject <SocketManagerSpec>
/// The socket associated with the default namespace (“/”).
@property (nonatomic, readonly, strong) SocketIOClient * _Nonnull defaultSocket;
/// The URL of the socket.io server.
/// If changed after calling <code>init</code>, <code>forceNew</code> must be set to <code>true</code>, or it will only connect to the url set in the
/// init.
@property (nonatomic, readonly, copy) NSURL * _Nonnull socketURL;
/// The engine for this manager.
@property (nonatomic, strong) id <SocketEngineSpec> _Nullable engine;
/// If <code>true</code> then every time <code>connect</code> is called, a new engine will be created.
@property (nonatomic) BOOL forceNew;
/// The queue that all interaction with the client should occur on. This is the queue that event handlers are
/// called on.
/// <em>This should be a serial queue! Concurrent queues are not supported and might cause crashes and races</em>.
@property (nonatomic, strong) dispatch_queue_t _Nonnull handleQueue;
/// The sockets in this manager indexed by namespace.
@property (nonatomic, copy) NSDictionary<NSString *, SocketIOClient *> * _Nonnull nsps;
/// If <code>true</code>, this client will try and reconnect on any disconnects.
@property (nonatomic) BOOL reconnects;
/// The minimum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWait;
/// The maximum number of seconds to wait before attempting to reconnect.
@property (nonatomic) NSInteger reconnectWaitMax;
/// The randomization factor for calculating reconnect jitter.
@property (nonatomic) double randomizationFactor;
/// The status of this manager.
@property (nonatomic, readonly) enum SocketIOStatus status;
/// Not so type safe way to create a SocketIOClient, meant for Objective-C compatiblity.
/// If using Swift it’s recommended to use <code>init(socketURL: NSURL, options: Set<SocketIOClientOption>)</code>
/// \param socketURL The url of the socket.io server.
///
/// \param config The config for this socket.
///
- (nonnull instancetype)initWithSocketURL:(NSURL * _Nonnull)socketURL config:(NSDictionary<NSString *, id> * _Nullable)config;
/// Connects the underlying transport and the default namespace socket.
/// Override if you wish to attach a custom <code>SocketEngineSpec</code>.
- (void)connect;
/// Connects a socket through this manager’s engine.
/// \param socket The socket who we should connect through this manager.
///
- (void)connectSocket:(SocketIOClient * _Nonnull)socket;
/// Called when the manager has disconnected from socket.io.
/// \param reason The reason for the disconnection.
///
- (void)didDisconnectWithReason:(NSString * _Nonnull)reason;
/// Disconnects the manager and all associated sockets.
- (void)disconnect;
/// Disconnects the given socket.
/// This will remove the socket for the manager’s control, and make the socket instance useless and ready for
/// releasing.
/// \param socket The socket to disconnect.
///
- (void)disconnectSocket:(SocketIOClient * _Nonnull)socket;
/// Disconnects the socket associated with <code>forNamespace</code>.
/// This will remove the socket for the manager’s control, and make the socket instance useless and ready for
/// releasing.
/// \param nsp The namespace to disconnect from.
///
- (void)disconnectSocketForNamespace:(NSString * _Nonnull)nsp;
/// Sends an event to the server on all namespaces in this manager.
/// Same as <code>emitAll(_:_:)</code>, but meant for Objective-C.
/// \param event The event to send.
///
/// \param items The data to send with this event.
///
- (void)emitAll:(NSString * _Nonnull)event withItems:(NSArray * _Nonnull)items;
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine receives a pong message.
- (void)engineDidReceivePong;
/// Called when the sends a ping to the server.
- (void)engineDidSendPing;
/// Called when when upgrading the http connection to a websocket connection.
/// \param headers The http headers.
///
- (void)engineDidWebsocketUpgradeWithHeaders:(NSDictionary<NSString *, NSString *> * _Nonnull)headers;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
/// Tries to reconnect to the server.
/// This will cause a <code>SocketClientEvent.reconnect</code> event to be emitted, as well as
/// <code>SocketClientEvent.reconnectAttempt</code> events.
- (void)reconnect;
/// Removes the socket from the manager’s control. One of the disconnect methods should be called before calling this
/// method.
/// After calling this method the socket should no longer be considered usable.
/// \param socket The socket to remove.
///
///
/// returns:
/// The socket removed, if it was owned by the manager.
- (SocketIOClient * _Nullable)removeSocket:(SocketIOClient * _Nonnull)socket;
/// Returns a <code>SocketIOClient</code> for the given namespace. This socket shares a transport with the manager.
/// Calling multiple times returns the same socket.
/// Sockets created from this method are retained by the manager.
/// Call one of the <code>disconnectSocket</code> methods on this class to remove the socket from manager control.
/// Or call <code>SocketIOClient.disconnect()</code> on the client.
/// \param nsp The namespace for the socket.
///
///
/// returns:
/// A <code>SocketIOClient</code> for the given namespace.
- (SocketIOClient * _Nonnull)socketForNamespace:(NSString * _Nonnull)nsp SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Class that gives a backwards compatible way to cause an emit not to recursively check for Data objects.
/// Usage:
/// \code
/// ack.rawEmitView.with(myObject)
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK16SocketRawAckView")
@interface SocketRawAckView : NSObject
/// Call to ack receiving this event.
/// \param items An array of items to send when acking. Use <code>[]</code> to send nothing.
///
- (void)with:(NSArray * _Nonnull)items;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Class that gives a backwards compatible way to cause an emit not to recursively check for Data objects.
/// Usage:
/// \code
/// socket.rawEmitView.emit("myEvent", myObject)
///
/// \endcode
SWIFT_CLASS("_TtC8AmitySDK13SocketRawView")
@interface SocketRawView : NSObject
/// Same as emit, but meant for Objective-C
/// \param event The event to send.
///
/// \param items The items to send with this event. Send an empty array to send no data.
///
- (void)emit:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items;
/// Same as emitWithAck, but for Objective-C
/// <em>NOTE</em>: It is up to the server send an ack back, just calling this method does not mean the server will ack.
/// Check that your server’s api will ack the event being sent.
/// Example:
/// \code
/// socket.emitWithAck("myEvent", with: [1]).timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode\param event The event to send.
///
/// \param items The items to send with this event. Use <code>[]</code> to send nothing.
///
///
/// returns:
/// An <code>OnAckCallback</code>. You must call the <code>timingOut(after:)</code> method before the event will be sent.
- (OnAckCallback * _Nonnull)emitWithAck:(NSString * _Nonnull)event with:(NSArray * _Nonnull)items SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





SWIFT_CLASS("_TtC8AmitySDK9WebSocket")
@interface WebSocket : NSObject <NSStreamDelegate>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#endif
